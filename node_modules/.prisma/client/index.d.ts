
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  name: string
  type: string
  subtype: string
  description: string
  memory: string
  imageUrl: string
  price: number
  availability: boolean
  priceForTwo: number
  updateTimes: number
}

/**
 * Model Appetizer
 * 
 */
export type Appetizer = {
  id: string
  name: string
  description: string
  imageURL: string
  price: number
  availability: boolean
  updateTimes: number
}

/**
 * Model Salad
 * 
 */
export type Salad = {
  id: string
  name: string
  subtype: string
  description: string
  imageURL: string
  price: number
  availability: boolean
  updateTimes: number
}

/**
 * Model MainDishe
 * 
 */
export type MainDishe = {
  id: string
  name: string
  subtype: string
  description: string
  imageURL: string
  price: number
  priceForTwo: number
  availability: boolean
  updateTimes: number
}

/**
 * Model Drink
 * 
 */
export type Drink = {
  id: string
  name: string
  subtype: string
  imageURL: string
  description: string
  price: number
  availability: boolean
  updateTimes: number
}

/**
 * Model Dessert
 * 
 */
export type Dessert = {
  id: string
  name: string
  description: string
  imageURL: string
  price: number
  availability: boolean
  updateTimes: number
}

/**
 * Model ExtraPortion
 * 
 */
export type ExtraPortion = {
  id: string
  name: string
  price: number
  availability: boolean
}

/**
 * Model Pets
 * 
 */
export type Pets = {
  id: string
  name: string
  description: string
  price: number
  availability: boolean
}

/**
 * Model Wine
 * 
 */
export type Wine = {
  id: string
  name: string
  glassPrice: number
  bottlePrice: number
  imageUrl: string
  country: string
  availability: boolean
  updateTimes: number
}

/**
 * Model Admin
 * 
 */
export type Admin = {
  id: string
  name: string
  password: string
  accountType: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Products
 * const products = await prisma.product.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): PrismaPromise<Prisma.JsonObject>;

      /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.appetizer`: Exposes CRUD operations for the **Appetizer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appetizers
    * const appetizers = await prisma.appetizer.findMany()
    * ```
    */
  get appetizer(): Prisma.AppetizerDelegate<GlobalReject>;

  /**
   * `prisma.salad`: Exposes CRUD operations for the **Salad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salads
    * const salads = await prisma.salad.findMany()
    * ```
    */
  get salad(): Prisma.SaladDelegate<GlobalReject>;

  /**
   * `prisma.mainDishe`: Exposes CRUD operations for the **MainDishe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainDishes
    * const mainDishes = await prisma.mainDishe.findMany()
    * ```
    */
  get mainDishe(): Prisma.MainDisheDelegate<GlobalReject>;

  /**
   * `prisma.drink`: Exposes CRUD operations for the **Drink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drinks
    * const drinks = await prisma.drink.findMany()
    * ```
    */
  get drink(): Prisma.DrinkDelegate<GlobalReject>;

  /**
   * `prisma.dessert`: Exposes CRUD operations for the **Dessert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Desserts
    * const desserts = await prisma.dessert.findMany()
    * ```
    */
  get dessert(): Prisma.DessertDelegate<GlobalReject>;

  /**
   * `prisma.extraPortion`: Exposes CRUD operations for the **ExtraPortion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtraPortions
    * const extraPortions = await prisma.extraPortion.findMany()
    * ```
    */
  get extraPortion(): Prisma.ExtraPortionDelegate<GlobalReject>;

  /**
   * `prisma.pets`: Exposes CRUD operations for the **Pets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pets
    * const pets = await prisma.pets.findMany()
    * ```
    */
  get pets(): Prisma.PetsDelegate<GlobalReject>;

  /**
   * `prisma.wine`: Exposes CRUD operations for the **Wine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wines
    * const wines = await prisma.wine.findMany()
    * ```
    */
  get wine(): Prisma.WineDelegate<GlobalReject>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.0.0
   * Query Engine version: da41d2bb3406da22087b849f0e911199ba4fbf11
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Product: 'Product',
    Appetizer: 'Appetizer',
    Salad: 'Salad',
    MainDishe: 'MainDishe',
    Drink: 'Drink',
    Dessert: 'Dessert',
    ExtraPortion: 'ExtraPortion',
    Pets: 'Pets',
    Wine: 'Wine',
    Admin: 'Admin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    subtype: string | null
    description: string | null
    memory: string | null
    imageUrl: string | null
    price: number | null
    availability: boolean | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    subtype: string | null
    description: string | null
    memory: string | null
    imageUrl: string | null
    price: number | null
    availability: boolean | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    type: number
    subtype: number
    description: number
    memory: number
    imageUrl: number
    price: number
    availability: number
    priceForTwo: number
    updateTimes: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subtype?: true
    description?: true
    memory?: true
    imageUrl?: true
    price?: true
    availability?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subtype?: true
    description?: true
    memory?: true
    imageUrl?: true
    price?: true
    availability?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subtype?: true
    description?: true
    memory?: true
    imageUrl?: true
    price?: true
    availability?: true
    priceForTwo?: true
    updateTimes?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    type: string
    subtype: string
    description: string
    memory: string
    imageUrl: string
    price: number
    availability: boolean
    priceForTwo: number
    updateTimes: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    type?: boolean
    subtype?: boolean
    description?: boolean
    memory?: boolean
    imageUrl?: boolean
    price?: boolean
    availability?: boolean
    priceForTwo?: boolean
    updateTimes?: boolean
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ProductFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ProductAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Product that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }

  /**
   * Product: findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product: findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product findRaw
   */
  export type ProductFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Product: findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = ProductFindUniqueArgsBase
      

  /**
   * Product: findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = ProductFindFirstArgsBase
      

  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
  }



  /**
   * Model Appetizer
   */


  export type AggregateAppetizer = {
    _count: AppetizerCountAggregateOutputType | null
    _avg: AppetizerAvgAggregateOutputType | null
    _sum: AppetizerSumAggregateOutputType | null
    _min: AppetizerMinAggregateOutputType | null
    _max: AppetizerMaxAggregateOutputType | null
  }

  export type AppetizerAvgAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type AppetizerSumAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type AppetizerMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type AppetizerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type AppetizerCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageURL: number
    price: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type AppetizerAvgAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type AppetizerSumAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type AppetizerMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type AppetizerMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type AppetizerCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type AppetizerAggregateArgs = {
    /**
     * Filter which Appetizer to aggregate.
     * 
    **/
    where?: AppetizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appetizers to fetch.
     * 
    **/
    orderBy?: Enumerable<AppetizerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppetizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appetizers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appetizers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appetizers
    **/
    _count?: true | AppetizerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppetizerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppetizerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppetizerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppetizerMaxAggregateInputType
  }

  export type GetAppetizerAggregateType<T extends AppetizerAggregateArgs> = {
        [P in keyof T & keyof AggregateAppetizer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppetizer[P]>
      : GetScalarType<T[P], AggregateAppetizer[P]>
  }




  export type AppetizerGroupByArgs = {
    where?: AppetizerWhereInput
    orderBy?: Enumerable<AppetizerOrderByWithAggregationInput>
    by: Array<AppetizerScalarFieldEnum>
    having?: AppetizerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppetizerCountAggregateInputType | true
    _avg?: AppetizerAvgAggregateInputType
    _sum?: AppetizerSumAggregateInputType
    _min?: AppetizerMinAggregateInputType
    _max?: AppetizerMaxAggregateInputType
  }


  export type AppetizerGroupByOutputType = {
    id: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
    _count: AppetizerCountAggregateOutputType | null
    _avg: AppetizerAvgAggregateOutputType | null
    _sum: AppetizerSumAggregateOutputType | null
    _min: AppetizerMinAggregateOutputType | null
    _max: AppetizerMaxAggregateOutputType | null
  }

  type GetAppetizerGroupByPayload<T extends AppetizerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AppetizerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppetizerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppetizerGroupByOutputType[P]>
            : GetScalarType<T[P], AppetizerGroupByOutputType[P]>
        }
      >
    >


  export type AppetizerSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageURL?: boolean
    price?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type AppetizerGetPayload<
    S extends boolean | null | undefined | AppetizerArgs,
    U = keyof S
      > = S extends true
        ? Appetizer
    : S extends undefined
    ? never
    : S extends AppetizerArgs | AppetizerFindManyArgs
    ?'include' extends U
    ? Appetizer 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Appetizer ? Appetizer[P] : never
  } 
    : Appetizer
  : Appetizer


  type AppetizerCountArgs = Merge<
    Omit<AppetizerFindManyArgs, 'select' | 'include'> & {
      select?: AppetizerCountAggregateInputType | true
    }
  >

  export interface AppetizerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Appetizer that matches the filter.
     * @param {AppetizerFindUniqueArgs} args - Arguments to find a Appetizer
     * @example
     * // Get one Appetizer
     * const appetizer = await prisma.appetizer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppetizerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppetizerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Appetizer'> extends True ? CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>> : CheckSelect<T, Prisma__AppetizerClient<Appetizer | null >, Prisma__AppetizerClient<AppetizerGetPayload<T> | null >>

    /**
     * Find the first Appetizer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerFindFirstArgs} args - Arguments to find a Appetizer
     * @example
     * // Get one Appetizer
     * const appetizer = await prisma.appetizer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppetizerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppetizerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Appetizer'> extends True ? CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>> : CheckSelect<T, Prisma__AppetizerClient<Appetizer | null >, Prisma__AppetizerClient<AppetizerGetPayload<T> | null >>

    /**
     * Find zero or more Appetizers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appetizers
     * const appetizers = await prisma.appetizer.findMany()
     * 
     * // Get first 10 Appetizers
     * const appetizers = await prisma.appetizer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appetizerWithIdOnly = await prisma.appetizer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppetizerFindManyArgs>(
      args?: SelectSubset<T, AppetizerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Appetizer>>, PrismaPromise<Array<AppetizerGetPayload<T>>>>

    /**
     * Create a Appetizer.
     * @param {AppetizerCreateArgs} args - Arguments to create a Appetizer.
     * @example
     * // Create one Appetizer
     * const Appetizer = await prisma.appetizer.create({
     *   data: {
     *     // ... data to create a Appetizer
     *   }
     * })
     * 
    **/
    create<T extends AppetizerCreateArgs>(
      args: SelectSubset<T, AppetizerCreateArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Create many Appetizers.
     *     @param {AppetizerCreateManyArgs} args - Arguments to create many Appetizers.
     *     @example
     *     // Create many Appetizers
     *     const appetizer = await prisma.appetizer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppetizerCreateManyArgs>(
      args?: SelectSubset<T, AppetizerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Appetizer.
     * @param {AppetizerDeleteArgs} args - Arguments to delete one Appetizer.
     * @example
     * // Delete one Appetizer
     * const Appetizer = await prisma.appetizer.delete({
     *   where: {
     *     // ... filter to delete one Appetizer
     *   }
     * })
     * 
    **/
    delete<T extends AppetizerDeleteArgs>(
      args: SelectSubset<T, AppetizerDeleteArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Update one Appetizer.
     * @param {AppetizerUpdateArgs} args - Arguments to update one Appetizer.
     * @example
     * // Update one Appetizer
     * const appetizer = await prisma.appetizer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppetizerUpdateArgs>(
      args: SelectSubset<T, AppetizerUpdateArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Delete zero or more Appetizers.
     * @param {AppetizerDeleteManyArgs} args - Arguments to filter Appetizers to delete.
     * @example
     * // Delete a few Appetizers
     * const { count } = await prisma.appetizer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppetizerDeleteManyArgs>(
      args?: SelectSubset<T, AppetizerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appetizers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appetizers
     * const appetizer = await prisma.appetizer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppetizerUpdateManyArgs>(
      args: SelectSubset<T, AppetizerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Appetizer.
     * @param {AppetizerUpsertArgs} args - Arguments to update or create a Appetizer.
     * @example
     * // Update or create a Appetizer
     * const appetizer = await prisma.appetizer.upsert({
     *   create: {
     *     // ... data to create a Appetizer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appetizer we want to update
     *   }
     * })
    **/
    upsert<T extends AppetizerUpsertArgs>(
      args: SelectSubset<T, AppetizerUpsertArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Find zero or more Appetizers that matches the filter.
     * @param {AppetizerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const appetizer = await prisma.appetizer.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AppetizerFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Appetizer.
     * @param {AppetizerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const appetizer = await prisma.appetizer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AppetizerAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Appetizer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AppetizerFindUniqueOrThrowArgs} args - Arguments to find a Appetizer
     * @example
     * // Get one Appetizer
     * const appetizer = await prisma.appetizer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppetizerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AppetizerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Find the first Appetizer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerFindFirstOrThrowArgs} args - Arguments to find a Appetizer
     * @example
     * // Get one Appetizer
     * const appetizer = await prisma.appetizer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppetizerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AppetizerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AppetizerClient<Appetizer>, Prisma__AppetizerClient<AppetizerGetPayload<T>>>

    /**
     * Count the number of Appetizers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerCountArgs} args - Arguments to filter Appetizers to count.
     * @example
     * // Count the number of Appetizers
     * const count = await prisma.appetizer.count({
     *   where: {
     *     // ... the filter for the Appetizers we want to count
     *   }
     * })
    **/
    count<T extends AppetizerCountArgs>(
      args?: Subset<T, AppetizerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppetizerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appetizer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppetizerAggregateArgs>(args: Subset<T, AppetizerAggregateArgs>): PrismaPromise<GetAppetizerAggregateType<T>>

    /**
     * Group by Appetizer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppetizerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppetizerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppetizerGroupByArgs['orderBy'] }
        : { orderBy?: AppetizerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppetizerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppetizerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appetizer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppetizerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Appetizer base type for findUnique actions
   */
  export type AppetizerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * Filter, which Appetizer to fetch.
     * 
    **/
    where: AppetizerWhereUniqueInput
  }

  /**
   * Appetizer: findUnique
   */
  export interface AppetizerFindUniqueArgs extends AppetizerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Appetizer base type for findFirst actions
   */
  export type AppetizerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * Filter, which Appetizer to fetch.
     * 
    **/
    where?: AppetizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appetizers to fetch.
     * 
    **/
    orderBy?: Enumerable<AppetizerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appetizers.
     * 
    **/
    cursor?: AppetizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appetizers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appetizers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appetizers.
     * 
    **/
    distinct?: Enumerable<AppetizerScalarFieldEnum>
  }

  /**
   * Appetizer: findFirst
   */
  export interface AppetizerFindFirstArgs extends AppetizerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Appetizer findMany
   */
  export type AppetizerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * Filter, which Appetizers to fetch.
     * 
    **/
    where?: AppetizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appetizers to fetch.
     * 
    **/
    orderBy?: Enumerable<AppetizerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appetizers.
     * 
    **/
    cursor?: AppetizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appetizers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appetizers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppetizerScalarFieldEnum>
  }


  /**
   * Appetizer create
   */
  export type AppetizerCreateArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * The data needed to create a Appetizer.
     * 
    **/
    data: XOR<AppetizerCreateInput, AppetizerUncheckedCreateInput>
  }


  /**
   * Appetizer createMany
   */
  export type AppetizerCreateManyArgs = {
    /**
     * The data used to create many Appetizers.
     * 
    **/
    data: Enumerable<AppetizerCreateManyInput>
  }


  /**
   * Appetizer update
   */
  export type AppetizerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * The data needed to update a Appetizer.
     * 
    **/
    data: XOR<AppetizerUpdateInput, AppetizerUncheckedUpdateInput>
    /**
     * Choose, which Appetizer to update.
     * 
    **/
    where: AppetizerWhereUniqueInput
  }


  /**
   * Appetizer updateMany
   */
  export type AppetizerUpdateManyArgs = {
    /**
     * The data used to update Appetizers.
     * 
    **/
    data: XOR<AppetizerUpdateManyMutationInput, AppetizerUncheckedUpdateManyInput>
    /**
     * Filter which Appetizers to update
     * 
    **/
    where?: AppetizerWhereInput
  }


  /**
   * Appetizer upsert
   */
  export type AppetizerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * The filter to search for the Appetizer to update in case it exists.
     * 
    **/
    where: AppetizerWhereUniqueInput
    /**
     * In case the Appetizer found by the `where` argument doesn't exist, create a new Appetizer with this data.
     * 
    **/
    create: XOR<AppetizerCreateInput, AppetizerUncheckedCreateInput>
    /**
     * In case the Appetizer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppetizerUpdateInput, AppetizerUncheckedUpdateInput>
  }


  /**
   * Appetizer delete
   */
  export type AppetizerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
    /**
     * Filter which Appetizer to delete.
     * 
    **/
    where: AppetizerWhereUniqueInput
  }


  /**
   * Appetizer deleteMany
   */
  export type AppetizerDeleteManyArgs = {
    /**
     * Filter which Appetizers to delete
     * 
    **/
    where?: AppetizerWhereInput
  }


  /**
   * Appetizer findRaw
   */
  export type AppetizerFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Appetizer aggregateRaw
   */
  export type AppetizerAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Appetizer: findUniqueOrThrow
   */
  export type AppetizerFindUniqueOrThrowArgs = AppetizerFindUniqueArgsBase
      

  /**
   * Appetizer: findFirstOrThrow
   */
  export type AppetizerFindFirstOrThrowArgs = AppetizerFindFirstArgsBase
      

  /**
   * Appetizer without action
   */
  export type AppetizerArgs = {
    /**
     * Select specific fields to fetch from the Appetizer
     * 
    **/
    select?: AppetizerSelect | null
  }



  /**
   * Model Salad
   */


  export type AggregateSalad = {
    _count: SaladCountAggregateOutputType | null
    _avg: SaladAvgAggregateOutputType | null
    _sum: SaladSumAggregateOutputType | null
    _min: SaladMinAggregateOutputType | null
    _max: SaladMaxAggregateOutputType | null
  }

  export type SaladAvgAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type SaladSumAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type SaladMinAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type SaladMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type SaladCountAggregateOutputType = {
    id: number
    name: number
    subtype: number
    description: number
    imageURL: number
    price: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type SaladAvgAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type SaladSumAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type SaladMinAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type SaladMaxAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type SaladCountAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type SaladAggregateArgs = {
    /**
     * Filter which Salad to aggregate.
     * 
    **/
    where?: SaladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salads to fetch.
     * 
    **/
    orderBy?: Enumerable<SaladOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SaladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salads
    **/
    _count?: true | SaladCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaladAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaladSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaladMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaladMaxAggregateInputType
  }

  export type GetSaladAggregateType<T extends SaladAggregateArgs> = {
        [P in keyof T & keyof AggregateSalad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalad[P]>
      : GetScalarType<T[P], AggregateSalad[P]>
  }




  export type SaladGroupByArgs = {
    where?: SaladWhereInput
    orderBy?: Enumerable<SaladOrderByWithAggregationInput>
    by: Array<SaladScalarFieldEnum>
    having?: SaladScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaladCountAggregateInputType | true
    _avg?: SaladAvgAggregateInputType
    _sum?: SaladSumAggregateInputType
    _min?: SaladMinAggregateInputType
    _max?: SaladMaxAggregateInputType
  }


  export type SaladGroupByOutputType = {
    id: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
    _count: SaladCountAggregateOutputType | null
    _avg: SaladAvgAggregateOutputType | null
    _sum: SaladSumAggregateOutputType | null
    _min: SaladMinAggregateOutputType | null
    _max: SaladMaxAggregateOutputType | null
  }

  type GetSaladGroupByPayload<T extends SaladGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SaladGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaladGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaladGroupByOutputType[P]>
            : GetScalarType<T[P], SaladGroupByOutputType[P]>
        }
      >
    >


  export type SaladSelect = {
    id?: boolean
    name?: boolean
    subtype?: boolean
    description?: boolean
    imageURL?: boolean
    price?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type SaladGetPayload<
    S extends boolean | null | undefined | SaladArgs,
    U = keyof S
      > = S extends true
        ? Salad
    : S extends undefined
    ? never
    : S extends SaladArgs | SaladFindManyArgs
    ?'include' extends U
    ? Salad 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Salad ? Salad[P] : never
  } 
    : Salad
  : Salad


  type SaladCountArgs = Merge<
    Omit<SaladFindManyArgs, 'select' | 'include'> & {
      select?: SaladCountAggregateInputType | true
    }
  >

  export interface SaladDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Salad that matches the filter.
     * @param {SaladFindUniqueArgs} args - Arguments to find a Salad
     * @example
     * // Get one Salad
     * const salad = await prisma.salad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaladFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SaladFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Salad'> extends True ? CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>> : CheckSelect<T, Prisma__SaladClient<Salad | null >, Prisma__SaladClient<SaladGetPayload<T> | null >>

    /**
     * Find the first Salad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladFindFirstArgs} args - Arguments to find a Salad
     * @example
     * // Get one Salad
     * const salad = await prisma.salad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaladFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SaladFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Salad'> extends True ? CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>> : CheckSelect<T, Prisma__SaladClient<Salad | null >, Prisma__SaladClient<SaladGetPayload<T> | null >>

    /**
     * Find zero or more Salads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salads
     * const salads = await prisma.salad.findMany()
     * 
     * // Get first 10 Salads
     * const salads = await prisma.salad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saladWithIdOnly = await prisma.salad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaladFindManyArgs>(
      args?: SelectSubset<T, SaladFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Salad>>, PrismaPromise<Array<SaladGetPayload<T>>>>

    /**
     * Create a Salad.
     * @param {SaladCreateArgs} args - Arguments to create a Salad.
     * @example
     * // Create one Salad
     * const Salad = await prisma.salad.create({
     *   data: {
     *     // ... data to create a Salad
     *   }
     * })
     * 
    **/
    create<T extends SaladCreateArgs>(
      args: SelectSubset<T, SaladCreateArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Create many Salads.
     *     @param {SaladCreateManyArgs} args - Arguments to create many Salads.
     *     @example
     *     // Create many Salads
     *     const salad = await prisma.salad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SaladCreateManyArgs>(
      args?: SelectSubset<T, SaladCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Salad.
     * @param {SaladDeleteArgs} args - Arguments to delete one Salad.
     * @example
     * // Delete one Salad
     * const Salad = await prisma.salad.delete({
     *   where: {
     *     // ... filter to delete one Salad
     *   }
     * })
     * 
    **/
    delete<T extends SaladDeleteArgs>(
      args: SelectSubset<T, SaladDeleteArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Update one Salad.
     * @param {SaladUpdateArgs} args - Arguments to update one Salad.
     * @example
     * // Update one Salad
     * const salad = await prisma.salad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaladUpdateArgs>(
      args: SelectSubset<T, SaladUpdateArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Delete zero or more Salads.
     * @param {SaladDeleteManyArgs} args - Arguments to filter Salads to delete.
     * @example
     * // Delete a few Salads
     * const { count } = await prisma.salad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaladDeleteManyArgs>(
      args?: SelectSubset<T, SaladDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salads
     * const salad = await prisma.salad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaladUpdateManyArgs>(
      args: SelectSubset<T, SaladUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Salad.
     * @param {SaladUpsertArgs} args - Arguments to update or create a Salad.
     * @example
     * // Update or create a Salad
     * const salad = await prisma.salad.upsert({
     *   create: {
     *     // ... data to create a Salad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salad we want to update
     *   }
     * })
    **/
    upsert<T extends SaladUpsertArgs>(
      args: SelectSubset<T, SaladUpsertArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Find zero or more Salads that matches the filter.
     * @param {SaladFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const salad = await prisma.salad.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SaladFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Salad.
     * @param {SaladAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const salad = await prisma.salad.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SaladAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Salad that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SaladFindUniqueOrThrowArgs} args - Arguments to find a Salad
     * @example
     * // Get one Salad
     * const salad = await prisma.salad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SaladFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SaladFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Find the first Salad that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladFindFirstOrThrowArgs} args - Arguments to find a Salad
     * @example
     * // Get one Salad
     * const salad = await prisma.salad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SaladFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SaladFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SaladClient<Salad>, Prisma__SaladClient<SaladGetPayload<T>>>

    /**
     * Count the number of Salads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladCountArgs} args - Arguments to filter Salads to count.
     * @example
     * // Count the number of Salads
     * const count = await prisma.salad.count({
     *   where: {
     *     // ... the filter for the Salads we want to count
     *   }
     * })
    **/
    count<T extends SaladCountArgs>(
      args?: Subset<T, SaladCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaladCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaladAggregateArgs>(args: Subset<T, SaladAggregateArgs>): PrismaPromise<GetSaladAggregateType<T>>

    /**
     * Group by Salad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaladGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaladGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaladGroupByArgs['orderBy'] }
        : { orderBy?: SaladGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaladGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaladGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SaladClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Salad base type for findUnique actions
   */
  export type SaladFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * Filter, which Salad to fetch.
     * 
    **/
    where: SaladWhereUniqueInput
  }

  /**
   * Salad: findUnique
   */
  export interface SaladFindUniqueArgs extends SaladFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Salad base type for findFirst actions
   */
  export type SaladFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * Filter, which Salad to fetch.
     * 
    **/
    where?: SaladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salads to fetch.
     * 
    **/
    orderBy?: Enumerable<SaladOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salads.
     * 
    **/
    cursor?: SaladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salads.
     * 
    **/
    distinct?: Enumerable<SaladScalarFieldEnum>
  }

  /**
   * Salad: findFirst
   */
  export interface SaladFindFirstArgs extends SaladFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Salad findMany
   */
  export type SaladFindManyArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * Filter, which Salads to fetch.
     * 
    **/
    where?: SaladWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salads to fetch.
     * 
    **/
    orderBy?: Enumerable<SaladOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salads.
     * 
    **/
    cursor?: SaladWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SaladScalarFieldEnum>
  }


  /**
   * Salad create
   */
  export type SaladCreateArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * The data needed to create a Salad.
     * 
    **/
    data: XOR<SaladCreateInput, SaladUncheckedCreateInput>
  }


  /**
   * Salad createMany
   */
  export type SaladCreateManyArgs = {
    /**
     * The data used to create many Salads.
     * 
    **/
    data: Enumerable<SaladCreateManyInput>
  }


  /**
   * Salad update
   */
  export type SaladUpdateArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * The data needed to update a Salad.
     * 
    **/
    data: XOR<SaladUpdateInput, SaladUncheckedUpdateInput>
    /**
     * Choose, which Salad to update.
     * 
    **/
    where: SaladWhereUniqueInput
  }


  /**
   * Salad updateMany
   */
  export type SaladUpdateManyArgs = {
    /**
     * The data used to update Salads.
     * 
    **/
    data: XOR<SaladUpdateManyMutationInput, SaladUncheckedUpdateManyInput>
    /**
     * Filter which Salads to update
     * 
    **/
    where?: SaladWhereInput
  }


  /**
   * Salad upsert
   */
  export type SaladUpsertArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * The filter to search for the Salad to update in case it exists.
     * 
    **/
    where: SaladWhereUniqueInput
    /**
     * In case the Salad found by the `where` argument doesn't exist, create a new Salad with this data.
     * 
    **/
    create: XOR<SaladCreateInput, SaladUncheckedCreateInput>
    /**
     * In case the Salad was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SaladUpdateInput, SaladUncheckedUpdateInput>
  }


  /**
   * Salad delete
   */
  export type SaladDeleteArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
    /**
     * Filter which Salad to delete.
     * 
    **/
    where: SaladWhereUniqueInput
  }


  /**
   * Salad deleteMany
   */
  export type SaladDeleteManyArgs = {
    /**
     * Filter which Salads to delete
     * 
    **/
    where?: SaladWhereInput
  }


  /**
   * Salad findRaw
   */
  export type SaladFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Salad aggregateRaw
   */
  export type SaladAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Salad: findUniqueOrThrow
   */
  export type SaladFindUniqueOrThrowArgs = SaladFindUniqueArgsBase
      

  /**
   * Salad: findFirstOrThrow
   */
  export type SaladFindFirstOrThrowArgs = SaladFindFirstArgsBase
      

  /**
   * Salad without action
   */
  export type SaladArgs = {
    /**
     * Select specific fields to fetch from the Salad
     * 
    **/
    select?: SaladSelect | null
  }



  /**
   * Model MainDishe
   */


  export type AggregateMainDishe = {
    _count: MainDisheCountAggregateOutputType | null
    _avg: MainDisheAvgAggregateOutputType | null
    _sum: MainDisheSumAggregateOutputType | null
    _min: MainDisheMinAggregateOutputType | null
    _max: MainDisheMaxAggregateOutputType | null
  }

  export type MainDisheAvgAggregateOutputType = {
    price: number | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type MainDisheSumAggregateOutputType = {
    price: number | null
    priceForTwo: number | null
    updateTimes: number | null
  }

  export type MainDisheMinAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    priceForTwo: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type MainDisheMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    priceForTwo: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type MainDisheCountAggregateOutputType = {
    id: number
    name: number
    subtype: number
    description: number
    imageURL: number
    price: number
    priceForTwo: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type MainDisheAvgAggregateInputType = {
    price?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type MainDisheSumAggregateInputType = {
    price?: true
    priceForTwo?: true
    updateTimes?: true
  }

  export type MainDisheMinAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    priceForTwo?: true
    availability?: true
    updateTimes?: true
  }

  export type MainDisheMaxAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    priceForTwo?: true
    availability?: true
    updateTimes?: true
  }

  export type MainDisheCountAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    description?: true
    imageURL?: true
    price?: true
    priceForTwo?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type MainDisheAggregateArgs = {
    /**
     * Filter which MainDishe to aggregate.
     * 
    **/
    where?: MainDisheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainDishes to fetch.
     * 
    **/
    orderBy?: Enumerable<MainDisheOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MainDisheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainDishes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainDishes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainDishes
    **/
    _count?: true | MainDisheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainDisheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainDisheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainDisheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainDisheMaxAggregateInputType
  }

  export type GetMainDisheAggregateType<T extends MainDisheAggregateArgs> = {
        [P in keyof T & keyof AggregateMainDishe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainDishe[P]>
      : GetScalarType<T[P], AggregateMainDishe[P]>
  }




  export type MainDisheGroupByArgs = {
    where?: MainDisheWhereInput
    orderBy?: Enumerable<MainDisheOrderByWithAggregationInput>
    by: Array<MainDisheScalarFieldEnum>
    having?: MainDisheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainDisheCountAggregateInputType | true
    _avg?: MainDisheAvgAggregateInputType
    _sum?: MainDisheSumAggregateInputType
    _min?: MainDisheMinAggregateInputType
    _max?: MainDisheMaxAggregateInputType
  }


  export type MainDisheGroupByOutputType = {
    id: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    priceForTwo: number
    availability: boolean
    updateTimes: number
    _count: MainDisheCountAggregateOutputType | null
    _avg: MainDisheAvgAggregateOutputType | null
    _sum: MainDisheSumAggregateOutputType | null
    _min: MainDisheMinAggregateOutputType | null
    _max: MainDisheMaxAggregateOutputType | null
  }

  type GetMainDisheGroupByPayload<T extends MainDisheGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MainDisheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MainDisheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MainDisheGroupByOutputType[P]>
            : GetScalarType<T[P], MainDisheGroupByOutputType[P]>
        }
      >
    >


  export type MainDisheSelect = {
    id?: boolean
    name?: boolean
    subtype?: boolean
    description?: boolean
    imageURL?: boolean
    price?: boolean
    priceForTwo?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type MainDisheGetPayload<
    S extends boolean | null | undefined | MainDisheArgs,
    U = keyof S
      > = S extends true
        ? MainDishe
    : S extends undefined
    ? never
    : S extends MainDisheArgs | MainDisheFindManyArgs
    ?'include' extends U
    ? MainDishe 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MainDishe ? MainDishe[P] : never
  } 
    : MainDishe
  : MainDishe


  type MainDisheCountArgs = Merge<
    Omit<MainDisheFindManyArgs, 'select' | 'include'> & {
      select?: MainDisheCountAggregateInputType | true
    }
  >

  export interface MainDisheDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MainDishe that matches the filter.
     * @param {MainDisheFindUniqueArgs} args - Arguments to find a MainDishe
     * @example
     * // Get one MainDishe
     * const mainDishe = await prisma.mainDishe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MainDisheFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MainDisheFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MainDishe'> extends True ? CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>> : CheckSelect<T, Prisma__MainDisheClient<MainDishe | null >, Prisma__MainDisheClient<MainDisheGetPayload<T> | null >>

    /**
     * Find the first MainDishe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheFindFirstArgs} args - Arguments to find a MainDishe
     * @example
     * // Get one MainDishe
     * const mainDishe = await prisma.mainDishe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MainDisheFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MainDisheFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MainDishe'> extends True ? CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>> : CheckSelect<T, Prisma__MainDisheClient<MainDishe | null >, Prisma__MainDisheClient<MainDisheGetPayload<T> | null >>

    /**
     * Find zero or more MainDishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainDishes
     * const mainDishes = await prisma.mainDishe.findMany()
     * 
     * // Get first 10 MainDishes
     * const mainDishes = await prisma.mainDishe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainDisheWithIdOnly = await prisma.mainDishe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MainDisheFindManyArgs>(
      args?: SelectSubset<T, MainDisheFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MainDishe>>, PrismaPromise<Array<MainDisheGetPayload<T>>>>

    /**
     * Create a MainDishe.
     * @param {MainDisheCreateArgs} args - Arguments to create a MainDishe.
     * @example
     * // Create one MainDishe
     * const MainDishe = await prisma.mainDishe.create({
     *   data: {
     *     // ... data to create a MainDishe
     *   }
     * })
     * 
    **/
    create<T extends MainDisheCreateArgs>(
      args: SelectSubset<T, MainDisheCreateArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Create many MainDishes.
     *     @param {MainDisheCreateManyArgs} args - Arguments to create many MainDishes.
     *     @example
     *     // Create many MainDishes
     *     const mainDishe = await prisma.mainDishe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MainDisheCreateManyArgs>(
      args?: SelectSubset<T, MainDisheCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MainDishe.
     * @param {MainDisheDeleteArgs} args - Arguments to delete one MainDishe.
     * @example
     * // Delete one MainDishe
     * const MainDishe = await prisma.mainDishe.delete({
     *   where: {
     *     // ... filter to delete one MainDishe
     *   }
     * })
     * 
    **/
    delete<T extends MainDisheDeleteArgs>(
      args: SelectSubset<T, MainDisheDeleteArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Update one MainDishe.
     * @param {MainDisheUpdateArgs} args - Arguments to update one MainDishe.
     * @example
     * // Update one MainDishe
     * const mainDishe = await prisma.mainDishe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MainDisheUpdateArgs>(
      args: SelectSubset<T, MainDisheUpdateArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Delete zero or more MainDishes.
     * @param {MainDisheDeleteManyArgs} args - Arguments to filter MainDishes to delete.
     * @example
     * // Delete a few MainDishes
     * const { count } = await prisma.mainDishe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MainDisheDeleteManyArgs>(
      args?: SelectSubset<T, MainDisheDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainDishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainDishes
     * const mainDishe = await prisma.mainDishe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MainDisheUpdateManyArgs>(
      args: SelectSubset<T, MainDisheUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MainDishe.
     * @param {MainDisheUpsertArgs} args - Arguments to update or create a MainDishe.
     * @example
     * // Update or create a MainDishe
     * const mainDishe = await prisma.mainDishe.upsert({
     *   create: {
     *     // ... data to create a MainDishe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainDishe we want to update
     *   }
     * })
    **/
    upsert<T extends MainDisheUpsertArgs>(
      args: SelectSubset<T, MainDisheUpsertArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Find zero or more MainDishes that matches the filter.
     * @param {MainDisheFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mainDishe = await prisma.mainDishe.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MainDisheFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MainDishe.
     * @param {MainDisheAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mainDishe = await prisma.mainDishe.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MainDisheAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one MainDishe that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {MainDisheFindUniqueOrThrowArgs} args - Arguments to find a MainDishe
     * @example
     * // Get one MainDishe
     * const mainDishe = await prisma.mainDishe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MainDisheFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MainDisheFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Find the first MainDishe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheFindFirstOrThrowArgs} args - Arguments to find a MainDishe
     * @example
     * // Get one MainDishe
     * const mainDishe = await prisma.mainDishe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MainDisheFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MainDisheFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__MainDisheClient<MainDishe>, Prisma__MainDisheClient<MainDisheGetPayload<T>>>

    /**
     * Count the number of MainDishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheCountArgs} args - Arguments to filter MainDishes to count.
     * @example
     * // Count the number of MainDishes
     * const count = await prisma.mainDishe.count({
     *   where: {
     *     // ... the filter for the MainDishes we want to count
     *   }
     * })
    **/
    count<T extends MainDisheCountArgs>(
      args?: Subset<T, MainDisheCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainDisheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainDishe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainDisheAggregateArgs>(args: Subset<T, MainDisheAggregateArgs>): PrismaPromise<GetMainDisheAggregateType<T>>

    /**
     * Group by MainDishe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainDisheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainDisheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainDisheGroupByArgs['orderBy'] }
        : { orderBy?: MainDisheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainDisheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainDisheGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MainDishe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MainDisheClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MainDishe base type for findUnique actions
   */
  export type MainDisheFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * Filter, which MainDishe to fetch.
     * 
    **/
    where: MainDisheWhereUniqueInput
  }

  /**
   * MainDishe: findUnique
   */
  export interface MainDisheFindUniqueArgs extends MainDisheFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MainDishe base type for findFirst actions
   */
  export type MainDisheFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * Filter, which MainDishe to fetch.
     * 
    **/
    where?: MainDisheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainDishes to fetch.
     * 
    **/
    orderBy?: Enumerable<MainDisheOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainDishes.
     * 
    **/
    cursor?: MainDisheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainDishes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainDishes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainDishes.
     * 
    **/
    distinct?: Enumerable<MainDisheScalarFieldEnum>
  }

  /**
   * MainDishe: findFirst
   */
  export interface MainDisheFindFirstArgs extends MainDisheFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MainDishe findMany
   */
  export type MainDisheFindManyArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * Filter, which MainDishes to fetch.
     * 
    **/
    where?: MainDisheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainDishes to fetch.
     * 
    **/
    orderBy?: Enumerable<MainDisheOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainDishes.
     * 
    **/
    cursor?: MainDisheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainDishes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainDishes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MainDisheScalarFieldEnum>
  }


  /**
   * MainDishe create
   */
  export type MainDisheCreateArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * The data needed to create a MainDishe.
     * 
    **/
    data: XOR<MainDisheCreateInput, MainDisheUncheckedCreateInput>
  }


  /**
   * MainDishe createMany
   */
  export type MainDisheCreateManyArgs = {
    /**
     * The data used to create many MainDishes.
     * 
    **/
    data: Enumerable<MainDisheCreateManyInput>
  }


  /**
   * MainDishe update
   */
  export type MainDisheUpdateArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * The data needed to update a MainDishe.
     * 
    **/
    data: XOR<MainDisheUpdateInput, MainDisheUncheckedUpdateInput>
    /**
     * Choose, which MainDishe to update.
     * 
    **/
    where: MainDisheWhereUniqueInput
  }


  /**
   * MainDishe updateMany
   */
  export type MainDisheUpdateManyArgs = {
    /**
     * The data used to update MainDishes.
     * 
    **/
    data: XOR<MainDisheUpdateManyMutationInput, MainDisheUncheckedUpdateManyInput>
    /**
     * Filter which MainDishes to update
     * 
    **/
    where?: MainDisheWhereInput
  }


  /**
   * MainDishe upsert
   */
  export type MainDisheUpsertArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * The filter to search for the MainDishe to update in case it exists.
     * 
    **/
    where: MainDisheWhereUniqueInput
    /**
     * In case the MainDishe found by the `where` argument doesn't exist, create a new MainDishe with this data.
     * 
    **/
    create: XOR<MainDisheCreateInput, MainDisheUncheckedCreateInput>
    /**
     * In case the MainDishe was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MainDisheUpdateInput, MainDisheUncheckedUpdateInput>
  }


  /**
   * MainDishe delete
   */
  export type MainDisheDeleteArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
    /**
     * Filter which MainDishe to delete.
     * 
    **/
    where: MainDisheWhereUniqueInput
  }


  /**
   * MainDishe deleteMany
   */
  export type MainDisheDeleteManyArgs = {
    /**
     * Filter which MainDishes to delete
     * 
    **/
    where?: MainDisheWhereInput
  }


  /**
   * MainDishe findRaw
   */
  export type MainDisheFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MainDishe aggregateRaw
   */
  export type MainDisheAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MainDishe: findUniqueOrThrow
   */
  export type MainDisheFindUniqueOrThrowArgs = MainDisheFindUniqueArgsBase
      

  /**
   * MainDishe: findFirstOrThrow
   */
  export type MainDisheFindFirstOrThrowArgs = MainDisheFindFirstArgsBase
      

  /**
   * MainDishe without action
   */
  export type MainDisheArgs = {
    /**
     * Select specific fields to fetch from the MainDishe
     * 
    **/
    select?: MainDisheSelect | null
  }



  /**
   * Model Drink
   */


  export type AggregateDrink = {
    _count: DrinkCountAggregateOutputType | null
    _avg: DrinkAvgAggregateOutputType | null
    _sum: DrinkSumAggregateOutputType | null
    _min: DrinkMinAggregateOutputType | null
    _max: DrinkMaxAggregateOutputType | null
  }

  export type DrinkAvgAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type DrinkSumAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type DrinkMinAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    imageURL: string | null
    description: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type DrinkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subtype: string | null
    imageURL: string | null
    description: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type DrinkCountAggregateOutputType = {
    id: number
    name: number
    subtype: number
    imageURL: number
    description: number
    price: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type DrinkAvgAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type DrinkSumAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type DrinkMinAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    imageURL?: true
    description?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type DrinkMaxAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    imageURL?: true
    description?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type DrinkCountAggregateInputType = {
    id?: true
    name?: true
    subtype?: true
    imageURL?: true
    description?: true
    price?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type DrinkAggregateArgs = {
    /**
     * Filter which Drink to aggregate.
     * 
    **/
    where?: DrinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drinks to fetch.
     * 
    **/
    orderBy?: Enumerable<DrinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DrinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drinks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drinks
    **/
    _count?: true | DrinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrinkMaxAggregateInputType
  }

  export type GetDrinkAggregateType<T extends DrinkAggregateArgs> = {
        [P in keyof T & keyof AggregateDrink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrink[P]>
      : GetScalarType<T[P], AggregateDrink[P]>
  }




  export type DrinkGroupByArgs = {
    where?: DrinkWhereInput
    orderBy?: Enumerable<DrinkOrderByWithAggregationInput>
    by: Array<DrinkScalarFieldEnum>
    having?: DrinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrinkCountAggregateInputType | true
    _avg?: DrinkAvgAggregateInputType
    _sum?: DrinkSumAggregateInputType
    _min?: DrinkMinAggregateInputType
    _max?: DrinkMaxAggregateInputType
  }


  export type DrinkGroupByOutputType = {
    id: string
    name: string
    subtype: string
    imageURL: string
    description: string
    price: number
    availability: boolean
    updateTimes: number
    _count: DrinkCountAggregateOutputType | null
    _avg: DrinkAvgAggregateOutputType | null
    _sum: DrinkSumAggregateOutputType | null
    _min: DrinkMinAggregateOutputType | null
    _max: DrinkMaxAggregateOutputType | null
  }

  type GetDrinkGroupByPayload<T extends DrinkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DrinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrinkGroupByOutputType[P]>
            : GetScalarType<T[P], DrinkGroupByOutputType[P]>
        }
      >
    >


  export type DrinkSelect = {
    id?: boolean
    name?: boolean
    subtype?: boolean
    imageURL?: boolean
    description?: boolean
    price?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type DrinkGetPayload<
    S extends boolean | null | undefined | DrinkArgs,
    U = keyof S
      > = S extends true
        ? Drink
    : S extends undefined
    ? never
    : S extends DrinkArgs | DrinkFindManyArgs
    ?'include' extends U
    ? Drink 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Drink ? Drink[P] : never
  } 
    : Drink
  : Drink


  type DrinkCountArgs = Merge<
    Omit<DrinkFindManyArgs, 'select' | 'include'> & {
      select?: DrinkCountAggregateInputType | true
    }
  >

  export interface DrinkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Drink that matches the filter.
     * @param {DrinkFindUniqueArgs} args - Arguments to find a Drink
     * @example
     * // Get one Drink
     * const drink = await prisma.drink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DrinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DrinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Drink'> extends True ? CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>> : CheckSelect<T, Prisma__DrinkClient<Drink | null >, Prisma__DrinkClient<DrinkGetPayload<T> | null >>

    /**
     * Find the first Drink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkFindFirstArgs} args - Arguments to find a Drink
     * @example
     * // Get one Drink
     * const drink = await prisma.drink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DrinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DrinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Drink'> extends True ? CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>> : CheckSelect<T, Prisma__DrinkClient<Drink | null >, Prisma__DrinkClient<DrinkGetPayload<T> | null >>

    /**
     * Find zero or more Drinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drinks
     * const drinks = await prisma.drink.findMany()
     * 
     * // Get first 10 Drinks
     * const drinks = await prisma.drink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drinkWithIdOnly = await prisma.drink.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DrinkFindManyArgs>(
      args?: SelectSubset<T, DrinkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Drink>>, PrismaPromise<Array<DrinkGetPayload<T>>>>

    /**
     * Create a Drink.
     * @param {DrinkCreateArgs} args - Arguments to create a Drink.
     * @example
     * // Create one Drink
     * const Drink = await prisma.drink.create({
     *   data: {
     *     // ... data to create a Drink
     *   }
     * })
     * 
    **/
    create<T extends DrinkCreateArgs>(
      args: SelectSubset<T, DrinkCreateArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Create many Drinks.
     *     @param {DrinkCreateManyArgs} args - Arguments to create many Drinks.
     *     @example
     *     // Create many Drinks
     *     const drink = await prisma.drink.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DrinkCreateManyArgs>(
      args?: SelectSubset<T, DrinkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Drink.
     * @param {DrinkDeleteArgs} args - Arguments to delete one Drink.
     * @example
     * // Delete one Drink
     * const Drink = await prisma.drink.delete({
     *   where: {
     *     // ... filter to delete one Drink
     *   }
     * })
     * 
    **/
    delete<T extends DrinkDeleteArgs>(
      args: SelectSubset<T, DrinkDeleteArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Update one Drink.
     * @param {DrinkUpdateArgs} args - Arguments to update one Drink.
     * @example
     * // Update one Drink
     * const drink = await prisma.drink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DrinkUpdateArgs>(
      args: SelectSubset<T, DrinkUpdateArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Delete zero or more Drinks.
     * @param {DrinkDeleteManyArgs} args - Arguments to filter Drinks to delete.
     * @example
     * // Delete a few Drinks
     * const { count } = await prisma.drink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DrinkDeleteManyArgs>(
      args?: SelectSubset<T, DrinkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drinks
     * const drink = await prisma.drink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DrinkUpdateManyArgs>(
      args: SelectSubset<T, DrinkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Drink.
     * @param {DrinkUpsertArgs} args - Arguments to update or create a Drink.
     * @example
     * // Update or create a Drink
     * const drink = await prisma.drink.upsert({
     *   create: {
     *     // ... data to create a Drink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drink we want to update
     *   }
     * })
    **/
    upsert<T extends DrinkUpsertArgs>(
      args: SelectSubset<T, DrinkUpsertArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Find zero or more Drinks that matches the filter.
     * @param {DrinkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const drink = await prisma.drink.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DrinkFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Drink.
     * @param {DrinkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const drink = await prisma.drink.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DrinkAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Drink that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DrinkFindUniqueOrThrowArgs} args - Arguments to find a Drink
     * @example
     * // Get one Drink
     * const drink = await prisma.drink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DrinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DrinkFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Find the first Drink that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkFindFirstOrThrowArgs} args - Arguments to find a Drink
     * @example
     * // Get one Drink
     * const drink = await prisma.drink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DrinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DrinkFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DrinkClient<Drink>, Prisma__DrinkClient<DrinkGetPayload<T>>>

    /**
     * Count the number of Drinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkCountArgs} args - Arguments to filter Drinks to count.
     * @example
     * // Count the number of Drinks
     * const count = await prisma.drink.count({
     *   where: {
     *     // ... the filter for the Drinks we want to count
     *   }
     * })
    **/
    count<T extends DrinkCountArgs>(
      args?: Subset<T, DrinkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrinkAggregateArgs>(args: Subset<T, DrinkAggregateArgs>): PrismaPromise<GetDrinkAggregateType<T>>

    /**
     * Group by Drink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrinkGroupByArgs['orderBy'] }
        : { orderBy?: DrinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrinkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Drink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DrinkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Drink base type for findUnique actions
   */
  export type DrinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * Filter, which Drink to fetch.
     * 
    **/
    where: DrinkWhereUniqueInput
  }

  /**
   * Drink: findUnique
   */
  export interface DrinkFindUniqueArgs extends DrinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drink base type for findFirst actions
   */
  export type DrinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * Filter, which Drink to fetch.
     * 
    **/
    where?: DrinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drinks to fetch.
     * 
    **/
    orderBy?: Enumerable<DrinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drinks.
     * 
    **/
    cursor?: DrinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drinks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drinks.
     * 
    **/
    distinct?: Enumerable<DrinkScalarFieldEnum>
  }

  /**
   * Drink: findFirst
   */
  export interface DrinkFindFirstArgs extends DrinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drink findMany
   */
  export type DrinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * Filter, which Drinks to fetch.
     * 
    **/
    where?: DrinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drinks to fetch.
     * 
    **/
    orderBy?: Enumerable<DrinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drinks.
     * 
    **/
    cursor?: DrinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drinks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DrinkScalarFieldEnum>
  }


  /**
   * Drink create
   */
  export type DrinkCreateArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * The data needed to create a Drink.
     * 
    **/
    data: XOR<DrinkCreateInput, DrinkUncheckedCreateInput>
  }


  /**
   * Drink createMany
   */
  export type DrinkCreateManyArgs = {
    /**
     * The data used to create many Drinks.
     * 
    **/
    data: Enumerable<DrinkCreateManyInput>
  }


  /**
   * Drink update
   */
  export type DrinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * The data needed to update a Drink.
     * 
    **/
    data: XOR<DrinkUpdateInput, DrinkUncheckedUpdateInput>
    /**
     * Choose, which Drink to update.
     * 
    **/
    where: DrinkWhereUniqueInput
  }


  /**
   * Drink updateMany
   */
  export type DrinkUpdateManyArgs = {
    /**
     * The data used to update Drinks.
     * 
    **/
    data: XOR<DrinkUpdateManyMutationInput, DrinkUncheckedUpdateManyInput>
    /**
     * Filter which Drinks to update
     * 
    **/
    where?: DrinkWhereInput
  }


  /**
   * Drink upsert
   */
  export type DrinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * The filter to search for the Drink to update in case it exists.
     * 
    **/
    where: DrinkWhereUniqueInput
    /**
     * In case the Drink found by the `where` argument doesn't exist, create a new Drink with this data.
     * 
    **/
    create: XOR<DrinkCreateInput, DrinkUncheckedCreateInput>
    /**
     * In case the Drink was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DrinkUpdateInput, DrinkUncheckedUpdateInput>
  }


  /**
   * Drink delete
   */
  export type DrinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
    /**
     * Filter which Drink to delete.
     * 
    **/
    where: DrinkWhereUniqueInput
  }


  /**
   * Drink deleteMany
   */
  export type DrinkDeleteManyArgs = {
    /**
     * Filter which Drinks to delete
     * 
    **/
    where?: DrinkWhereInput
  }


  /**
   * Drink findRaw
   */
  export type DrinkFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Drink aggregateRaw
   */
  export type DrinkAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Drink: findUniqueOrThrow
   */
  export type DrinkFindUniqueOrThrowArgs = DrinkFindUniqueArgsBase
      

  /**
   * Drink: findFirstOrThrow
   */
  export type DrinkFindFirstOrThrowArgs = DrinkFindFirstArgsBase
      

  /**
   * Drink without action
   */
  export type DrinkArgs = {
    /**
     * Select specific fields to fetch from the Drink
     * 
    **/
    select?: DrinkSelect | null
  }



  /**
   * Model Dessert
   */


  export type AggregateDessert = {
    _count: DessertCountAggregateOutputType | null
    _avg: DessertAvgAggregateOutputType | null
    _sum: DessertSumAggregateOutputType | null
    _min: DessertMinAggregateOutputType | null
    _max: DessertMaxAggregateOutputType | null
  }

  export type DessertAvgAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type DessertSumAggregateOutputType = {
    price: number | null
    updateTimes: number | null
  }

  export type DessertMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type DessertMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageURL: string | null
    price: number | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type DessertCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageURL: number
    price: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type DessertAvgAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type DessertSumAggregateInputType = {
    price?: true
    updateTimes?: true
  }

  export type DessertMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type DessertMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
  }

  export type DessertCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageURL?: true
    price?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type DessertAggregateArgs = {
    /**
     * Filter which Dessert to aggregate.
     * 
    **/
    where?: DessertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desserts to fetch.
     * 
    **/
    orderBy?: Enumerable<DessertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DessertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desserts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desserts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Desserts
    **/
    _count?: true | DessertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DessertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DessertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DessertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DessertMaxAggregateInputType
  }

  export type GetDessertAggregateType<T extends DessertAggregateArgs> = {
        [P in keyof T & keyof AggregateDessert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDessert[P]>
      : GetScalarType<T[P], AggregateDessert[P]>
  }




  export type DessertGroupByArgs = {
    where?: DessertWhereInput
    orderBy?: Enumerable<DessertOrderByWithAggregationInput>
    by: Array<DessertScalarFieldEnum>
    having?: DessertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DessertCountAggregateInputType | true
    _avg?: DessertAvgAggregateInputType
    _sum?: DessertSumAggregateInputType
    _min?: DessertMinAggregateInputType
    _max?: DessertMaxAggregateInputType
  }


  export type DessertGroupByOutputType = {
    id: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
    _count: DessertCountAggregateOutputType | null
    _avg: DessertAvgAggregateOutputType | null
    _sum: DessertSumAggregateOutputType | null
    _min: DessertMinAggregateOutputType | null
    _max: DessertMaxAggregateOutputType | null
  }

  type GetDessertGroupByPayload<T extends DessertGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DessertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DessertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DessertGroupByOutputType[P]>
            : GetScalarType<T[P], DessertGroupByOutputType[P]>
        }
      >
    >


  export type DessertSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageURL?: boolean
    price?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type DessertGetPayload<
    S extends boolean | null | undefined | DessertArgs,
    U = keyof S
      > = S extends true
        ? Dessert
    : S extends undefined
    ? never
    : S extends DessertArgs | DessertFindManyArgs
    ?'include' extends U
    ? Dessert 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Dessert ? Dessert[P] : never
  } 
    : Dessert
  : Dessert


  type DessertCountArgs = Merge<
    Omit<DessertFindManyArgs, 'select' | 'include'> & {
      select?: DessertCountAggregateInputType | true
    }
  >

  export interface DessertDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Dessert that matches the filter.
     * @param {DessertFindUniqueArgs} args - Arguments to find a Dessert
     * @example
     * // Get one Dessert
     * const dessert = await prisma.dessert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DessertFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DessertFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dessert'> extends True ? CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>> : CheckSelect<T, Prisma__DessertClient<Dessert | null >, Prisma__DessertClient<DessertGetPayload<T> | null >>

    /**
     * Find the first Dessert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertFindFirstArgs} args - Arguments to find a Dessert
     * @example
     * // Get one Dessert
     * const dessert = await prisma.dessert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DessertFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DessertFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dessert'> extends True ? CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>> : CheckSelect<T, Prisma__DessertClient<Dessert | null >, Prisma__DessertClient<DessertGetPayload<T> | null >>

    /**
     * Find zero or more Desserts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Desserts
     * const desserts = await prisma.dessert.findMany()
     * 
     * // Get first 10 Desserts
     * const desserts = await prisma.dessert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dessertWithIdOnly = await prisma.dessert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DessertFindManyArgs>(
      args?: SelectSubset<T, DessertFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Dessert>>, PrismaPromise<Array<DessertGetPayload<T>>>>

    /**
     * Create a Dessert.
     * @param {DessertCreateArgs} args - Arguments to create a Dessert.
     * @example
     * // Create one Dessert
     * const Dessert = await prisma.dessert.create({
     *   data: {
     *     // ... data to create a Dessert
     *   }
     * })
     * 
    **/
    create<T extends DessertCreateArgs>(
      args: SelectSubset<T, DessertCreateArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Create many Desserts.
     *     @param {DessertCreateManyArgs} args - Arguments to create many Desserts.
     *     @example
     *     // Create many Desserts
     *     const dessert = await prisma.dessert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DessertCreateManyArgs>(
      args?: SelectSubset<T, DessertCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Dessert.
     * @param {DessertDeleteArgs} args - Arguments to delete one Dessert.
     * @example
     * // Delete one Dessert
     * const Dessert = await prisma.dessert.delete({
     *   where: {
     *     // ... filter to delete one Dessert
     *   }
     * })
     * 
    **/
    delete<T extends DessertDeleteArgs>(
      args: SelectSubset<T, DessertDeleteArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Update one Dessert.
     * @param {DessertUpdateArgs} args - Arguments to update one Dessert.
     * @example
     * // Update one Dessert
     * const dessert = await prisma.dessert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DessertUpdateArgs>(
      args: SelectSubset<T, DessertUpdateArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Delete zero or more Desserts.
     * @param {DessertDeleteManyArgs} args - Arguments to filter Desserts to delete.
     * @example
     * // Delete a few Desserts
     * const { count } = await prisma.dessert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DessertDeleteManyArgs>(
      args?: SelectSubset<T, DessertDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Desserts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Desserts
     * const dessert = await prisma.dessert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DessertUpdateManyArgs>(
      args: SelectSubset<T, DessertUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Dessert.
     * @param {DessertUpsertArgs} args - Arguments to update or create a Dessert.
     * @example
     * // Update or create a Dessert
     * const dessert = await prisma.dessert.upsert({
     *   create: {
     *     // ... data to create a Dessert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dessert we want to update
     *   }
     * })
    **/
    upsert<T extends DessertUpsertArgs>(
      args: SelectSubset<T, DessertUpsertArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Find zero or more Desserts that matches the filter.
     * @param {DessertFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dessert = await prisma.dessert.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DessertFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Dessert.
     * @param {DessertAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dessert = await prisma.dessert.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DessertAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Dessert that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DessertFindUniqueOrThrowArgs} args - Arguments to find a Dessert
     * @example
     * // Get one Dessert
     * const dessert = await prisma.dessert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DessertFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DessertFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Find the first Dessert that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertFindFirstOrThrowArgs} args - Arguments to find a Dessert
     * @example
     * // Get one Dessert
     * const dessert = await prisma.dessert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DessertFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DessertFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DessertClient<Dessert>, Prisma__DessertClient<DessertGetPayload<T>>>

    /**
     * Count the number of Desserts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertCountArgs} args - Arguments to filter Desserts to count.
     * @example
     * // Count the number of Desserts
     * const count = await prisma.dessert.count({
     *   where: {
     *     // ... the filter for the Desserts we want to count
     *   }
     * })
    **/
    count<T extends DessertCountArgs>(
      args?: Subset<T, DessertCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DessertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dessert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DessertAggregateArgs>(args: Subset<T, DessertAggregateArgs>): PrismaPromise<GetDessertAggregateType<T>>

    /**
     * Group by Dessert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DessertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DessertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DessertGroupByArgs['orderBy'] }
        : { orderBy?: DessertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DessertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDessertGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dessert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DessertClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Dessert base type for findUnique actions
   */
  export type DessertFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * Filter, which Dessert to fetch.
     * 
    **/
    where: DessertWhereUniqueInput
  }

  /**
   * Dessert: findUnique
   */
  export interface DessertFindUniqueArgs extends DessertFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dessert base type for findFirst actions
   */
  export type DessertFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * Filter, which Dessert to fetch.
     * 
    **/
    where?: DessertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desserts to fetch.
     * 
    **/
    orderBy?: Enumerable<DessertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Desserts.
     * 
    **/
    cursor?: DessertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desserts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desserts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Desserts.
     * 
    **/
    distinct?: Enumerable<DessertScalarFieldEnum>
  }

  /**
   * Dessert: findFirst
   */
  export interface DessertFindFirstArgs extends DessertFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dessert findMany
   */
  export type DessertFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * Filter, which Desserts to fetch.
     * 
    **/
    where?: DessertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desserts to fetch.
     * 
    **/
    orderBy?: Enumerable<DessertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Desserts.
     * 
    **/
    cursor?: DessertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desserts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desserts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DessertScalarFieldEnum>
  }


  /**
   * Dessert create
   */
  export type DessertCreateArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * The data needed to create a Dessert.
     * 
    **/
    data: XOR<DessertCreateInput, DessertUncheckedCreateInput>
  }


  /**
   * Dessert createMany
   */
  export type DessertCreateManyArgs = {
    /**
     * The data used to create many Desserts.
     * 
    **/
    data: Enumerable<DessertCreateManyInput>
  }


  /**
   * Dessert update
   */
  export type DessertUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * The data needed to update a Dessert.
     * 
    **/
    data: XOR<DessertUpdateInput, DessertUncheckedUpdateInput>
    /**
     * Choose, which Dessert to update.
     * 
    **/
    where: DessertWhereUniqueInput
  }


  /**
   * Dessert updateMany
   */
  export type DessertUpdateManyArgs = {
    /**
     * The data used to update Desserts.
     * 
    **/
    data: XOR<DessertUpdateManyMutationInput, DessertUncheckedUpdateManyInput>
    /**
     * Filter which Desserts to update
     * 
    **/
    where?: DessertWhereInput
  }


  /**
   * Dessert upsert
   */
  export type DessertUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * The filter to search for the Dessert to update in case it exists.
     * 
    **/
    where: DessertWhereUniqueInput
    /**
     * In case the Dessert found by the `where` argument doesn't exist, create a new Dessert with this data.
     * 
    **/
    create: XOR<DessertCreateInput, DessertUncheckedCreateInput>
    /**
     * In case the Dessert was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DessertUpdateInput, DessertUncheckedUpdateInput>
  }


  /**
   * Dessert delete
   */
  export type DessertDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
    /**
     * Filter which Dessert to delete.
     * 
    **/
    where: DessertWhereUniqueInput
  }


  /**
   * Dessert deleteMany
   */
  export type DessertDeleteManyArgs = {
    /**
     * Filter which Desserts to delete
     * 
    **/
    where?: DessertWhereInput
  }


  /**
   * Dessert findRaw
   */
  export type DessertFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Dessert aggregateRaw
   */
  export type DessertAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Dessert: findUniqueOrThrow
   */
  export type DessertFindUniqueOrThrowArgs = DessertFindUniqueArgsBase
      

  /**
   * Dessert: findFirstOrThrow
   */
  export type DessertFindFirstOrThrowArgs = DessertFindFirstArgsBase
      

  /**
   * Dessert without action
   */
  export type DessertArgs = {
    /**
     * Select specific fields to fetch from the Dessert
     * 
    **/
    select?: DessertSelect | null
  }



  /**
   * Model ExtraPortion
   */


  export type AggregateExtraPortion = {
    _count: ExtraPortionCountAggregateOutputType | null
    _avg: ExtraPortionAvgAggregateOutputType | null
    _sum: ExtraPortionSumAggregateOutputType | null
    _min: ExtraPortionMinAggregateOutputType | null
    _max: ExtraPortionMaxAggregateOutputType | null
  }

  export type ExtraPortionAvgAggregateOutputType = {
    price: number | null
  }

  export type ExtraPortionSumAggregateOutputType = {
    price: number | null
  }

  export type ExtraPortionMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    availability: boolean | null
  }

  export type ExtraPortionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    availability: boolean | null
  }

  export type ExtraPortionCountAggregateOutputType = {
    id: number
    name: number
    price: number
    availability: number
    _all: number
  }


  export type ExtraPortionAvgAggregateInputType = {
    price?: true
  }

  export type ExtraPortionSumAggregateInputType = {
    price?: true
  }

  export type ExtraPortionMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    availability?: true
  }

  export type ExtraPortionMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    availability?: true
  }

  export type ExtraPortionCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    availability?: true
    _all?: true
  }

  export type ExtraPortionAggregateArgs = {
    /**
     * Filter which ExtraPortion to aggregate.
     * 
    **/
    where?: ExtraPortionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraPortions to fetch.
     * 
    **/
    orderBy?: Enumerable<ExtraPortionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExtraPortionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraPortions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraPortions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtraPortions
    **/
    _count?: true | ExtraPortionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtraPortionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtraPortionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtraPortionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtraPortionMaxAggregateInputType
  }

  export type GetExtraPortionAggregateType<T extends ExtraPortionAggregateArgs> = {
        [P in keyof T & keyof AggregateExtraPortion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtraPortion[P]>
      : GetScalarType<T[P], AggregateExtraPortion[P]>
  }




  export type ExtraPortionGroupByArgs = {
    where?: ExtraPortionWhereInput
    orderBy?: Enumerable<ExtraPortionOrderByWithAggregationInput>
    by: Array<ExtraPortionScalarFieldEnum>
    having?: ExtraPortionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtraPortionCountAggregateInputType | true
    _avg?: ExtraPortionAvgAggregateInputType
    _sum?: ExtraPortionSumAggregateInputType
    _min?: ExtraPortionMinAggregateInputType
    _max?: ExtraPortionMaxAggregateInputType
  }


  export type ExtraPortionGroupByOutputType = {
    id: string
    name: string
    price: number
    availability: boolean
    _count: ExtraPortionCountAggregateOutputType | null
    _avg: ExtraPortionAvgAggregateOutputType | null
    _sum: ExtraPortionSumAggregateOutputType | null
    _min: ExtraPortionMinAggregateOutputType | null
    _max: ExtraPortionMaxAggregateOutputType | null
  }

  type GetExtraPortionGroupByPayload<T extends ExtraPortionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExtraPortionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtraPortionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtraPortionGroupByOutputType[P]>
            : GetScalarType<T[P], ExtraPortionGroupByOutputType[P]>
        }
      >
    >


  export type ExtraPortionSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
    availability?: boolean
  }

  export type ExtraPortionGetPayload<
    S extends boolean | null | undefined | ExtraPortionArgs,
    U = keyof S
      > = S extends true
        ? ExtraPortion
    : S extends undefined
    ? never
    : S extends ExtraPortionArgs | ExtraPortionFindManyArgs
    ?'include' extends U
    ? ExtraPortion 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ExtraPortion ? ExtraPortion[P] : never
  } 
    : ExtraPortion
  : ExtraPortion


  type ExtraPortionCountArgs = Merge<
    Omit<ExtraPortionFindManyArgs, 'select' | 'include'> & {
      select?: ExtraPortionCountAggregateInputType | true
    }
  >

  export interface ExtraPortionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExtraPortion that matches the filter.
     * @param {ExtraPortionFindUniqueArgs} args - Arguments to find a ExtraPortion
     * @example
     * // Get one ExtraPortion
     * const extraPortion = await prisma.extraPortion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExtraPortionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExtraPortionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExtraPortion'> extends True ? CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>> : CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion | null >, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T> | null >>

    /**
     * Find the first ExtraPortion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionFindFirstArgs} args - Arguments to find a ExtraPortion
     * @example
     * // Get one ExtraPortion
     * const extraPortion = await prisma.extraPortion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExtraPortionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExtraPortionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExtraPortion'> extends True ? CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>> : CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion | null >, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T> | null >>

    /**
     * Find zero or more ExtraPortions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtraPortions
     * const extraPortions = await prisma.extraPortion.findMany()
     * 
     * // Get first 10 ExtraPortions
     * const extraPortions = await prisma.extraPortion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extraPortionWithIdOnly = await prisma.extraPortion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExtraPortionFindManyArgs>(
      args?: SelectSubset<T, ExtraPortionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExtraPortion>>, PrismaPromise<Array<ExtraPortionGetPayload<T>>>>

    /**
     * Create a ExtraPortion.
     * @param {ExtraPortionCreateArgs} args - Arguments to create a ExtraPortion.
     * @example
     * // Create one ExtraPortion
     * const ExtraPortion = await prisma.extraPortion.create({
     *   data: {
     *     // ... data to create a ExtraPortion
     *   }
     * })
     * 
    **/
    create<T extends ExtraPortionCreateArgs>(
      args: SelectSubset<T, ExtraPortionCreateArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Create many ExtraPortions.
     *     @param {ExtraPortionCreateManyArgs} args - Arguments to create many ExtraPortions.
     *     @example
     *     // Create many ExtraPortions
     *     const extraPortion = await prisma.extraPortion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExtraPortionCreateManyArgs>(
      args?: SelectSubset<T, ExtraPortionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExtraPortion.
     * @param {ExtraPortionDeleteArgs} args - Arguments to delete one ExtraPortion.
     * @example
     * // Delete one ExtraPortion
     * const ExtraPortion = await prisma.extraPortion.delete({
     *   where: {
     *     // ... filter to delete one ExtraPortion
     *   }
     * })
     * 
    **/
    delete<T extends ExtraPortionDeleteArgs>(
      args: SelectSubset<T, ExtraPortionDeleteArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Update one ExtraPortion.
     * @param {ExtraPortionUpdateArgs} args - Arguments to update one ExtraPortion.
     * @example
     * // Update one ExtraPortion
     * const extraPortion = await prisma.extraPortion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExtraPortionUpdateArgs>(
      args: SelectSubset<T, ExtraPortionUpdateArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Delete zero or more ExtraPortions.
     * @param {ExtraPortionDeleteManyArgs} args - Arguments to filter ExtraPortions to delete.
     * @example
     * // Delete a few ExtraPortions
     * const { count } = await prisma.extraPortion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExtraPortionDeleteManyArgs>(
      args?: SelectSubset<T, ExtraPortionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtraPortions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtraPortions
     * const extraPortion = await prisma.extraPortion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExtraPortionUpdateManyArgs>(
      args: SelectSubset<T, ExtraPortionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExtraPortion.
     * @param {ExtraPortionUpsertArgs} args - Arguments to update or create a ExtraPortion.
     * @example
     * // Update or create a ExtraPortion
     * const extraPortion = await prisma.extraPortion.upsert({
     *   create: {
     *     // ... data to create a ExtraPortion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtraPortion we want to update
     *   }
     * })
    **/
    upsert<T extends ExtraPortionUpsertArgs>(
      args: SelectSubset<T, ExtraPortionUpsertArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Find zero or more ExtraPortions that matches the filter.
     * @param {ExtraPortionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const extraPortion = await prisma.extraPortion.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ExtraPortionFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ExtraPortion.
     * @param {ExtraPortionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const extraPortion = await prisma.extraPortion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ExtraPortionAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one ExtraPortion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ExtraPortionFindUniqueOrThrowArgs} args - Arguments to find a ExtraPortion
     * @example
     * // Get one ExtraPortion
     * const extraPortion = await prisma.extraPortion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExtraPortionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExtraPortionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Find the first ExtraPortion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionFindFirstOrThrowArgs} args - Arguments to find a ExtraPortion
     * @example
     * // Get one ExtraPortion
     * const extraPortion = await prisma.extraPortion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExtraPortionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExtraPortionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ExtraPortionClient<ExtraPortion>, Prisma__ExtraPortionClient<ExtraPortionGetPayload<T>>>

    /**
     * Count the number of ExtraPortions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionCountArgs} args - Arguments to filter ExtraPortions to count.
     * @example
     * // Count the number of ExtraPortions
     * const count = await prisma.extraPortion.count({
     *   where: {
     *     // ... the filter for the ExtraPortions we want to count
     *   }
     * })
    **/
    count<T extends ExtraPortionCountArgs>(
      args?: Subset<T, ExtraPortionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtraPortionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtraPortion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtraPortionAggregateArgs>(args: Subset<T, ExtraPortionAggregateArgs>): PrismaPromise<GetExtraPortionAggregateType<T>>

    /**
     * Group by ExtraPortion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraPortionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtraPortionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtraPortionGroupByArgs['orderBy'] }
        : { orderBy?: ExtraPortionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtraPortionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtraPortionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtraPortion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExtraPortionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExtraPortion base type for findUnique actions
   */
  export type ExtraPortionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * Filter, which ExtraPortion to fetch.
     * 
    **/
    where: ExtraPortionWhereUniqueInput
  }

  /**
   * ExtraPortion: findUnique
   */
  export interface ExtraPortionFindUniqueArgs extends ExtraPortionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExtraPortion base type for findFirst actions
   */
  export type ExtraPortionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * Filter, which ExtraPortion to fetch.
     * 
    **/
    where?: ExtraPortionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraPortions to fetch.
     * 
    **/
    orderBy?: Enumerable<ExtraPortionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraPortions.
     * 
    **/
    cursor?: ExtraPortionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraPortions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraPortions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraPortions.
     * 
    **/
    distinct?: Enumerable<ExtraPortionScalarFieldEnum>
  }

  /**
   * ExtraPortion: findFirst
   */
  export interface ExtraPortionFindFirstArgs extends ExtraPortionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExtraPortion findMany
   */
  export type ExtraPortionFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * Filter, which ExtraPortions to fetch.
     * 
    **/
    where?: ExtraPortionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraPortions to fetch.
     * 
    **/
    orderBy?: Enumerable<ExtraPortionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtraPortions.
     * 
    **/
    cursor?: ExtraPortionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraPortions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraPortions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExtraPortionScalarFieldEnum>
  }


  /**
   * ExtraPortion create
   */
  export type ExtraPortionCreateArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * The data needed to create a ExtraPortion.
     * 
    **/
    data: XOR<ExtraPortionCreateInput, ExtraPortionUncheckedCreateInput>
  }


  /**
   * ExtraPortion createMany
   */
  export type ExtraPortionCreateManyArgs = {
    /**
     * The data used to create many ExtraPortions.
     * 
    **/
    data: Enumerable<ExtraPortionCreateManyInput>
  }


  /**
   * ExtraPortion update
   */
  export type ExtraPortionUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * The data needed to update a ExtraPortion.
     * 
    **/
    data: XOR<ExtraPortionUpdateInput, ExtraPortionUncheckedUpdateInput>
    /**
     * Choose, which ExtraPortion to update.
     * 
    **/
    where: ExtraPortionWhereUniqueInput
  }


  /**
   * ExtraPortion updateMany
   */
  export type ExtraPortionUpdateManyArgs = {
    /**
     * The data used to update ExtraPortions.
     * 
    **/
    data: XOR<ExtraPortionUpdateManyMutationInput, ExtraPortionUncheckedUpdateManyInput>
    /**
     * Filter which ExtraPortions to update
     * 
    **/
    where?: ExtraPortionWhereInput
  }


  /**
   * ExtraPortion upsert
   */
  export type ExtraPortionUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * The filter to search for the ExtraPortion to update in case it exists.
     * 
    **/
    where: ExtraPortionWhereUniqueInput
    /**
     * In case the ExtraPortion found by the `where` argument doesn't exist, create a new ExtraPortion with this data.
     * 
    **/
    create: XOR<ExtraPortionCreateInput, ExtraPortionUncheckedCreateInput>
    /**
     * In case the ExtraPortion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExtraPortionUpdateInput, ExtraPortionUncheckedUpdateInput>
  }


  /**
   * ExtraPortion delete
   */
  export type ExtraPortionDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
    /**
     * Filter which ExtraPortion to delete.
     * 
    **/
    where: ExtraPortionWhereUniqueInput
  }


  /**
   * ExtraPortion deleteMany
   */
  export type ExtraPortionDeleteManyArgs = {
    /**
     * Filter which ExtraPortions to delete
     * 
    **/
    where?: ExtraPortionWhereInput
  }


  /**
   * ExtraPortion findRaw
   */
  export type ExtraPortionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * ExtraPortion aggregateRaw
   */
  export type ExtraPortionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * ExtraPortion: findUniqueOrThrow
   */
  export type ExtraPortionFindUniqueOrThrowArgs = ExtraPortionFindUniqueArgsBase
      

  /**
   * ExtraPortion: findFirstOrThrow
   */
  export type ExtraPortionFindFirstOrThrowArgs = ExtraPortionFindFirstArgsBase
      

  /**
   * ExtraPortion without action
   */
  export type ExtraPortionArgs = {
    /**
     * Select specific fields to fetch from the ExtraPortion
     * 
    **/
    select?: ExtraPortionSelect | null
  }



  /**
   * Model Pets
   */


  export type AggregatePets = {
    _count: PetsCountAggregateOutputType | null
    _avg: PetsAvgAggregateOutputType | null
    _sum: PetsSumAggregateOutputType | null
    _min: PetsMinAggregateOutputType | null
    _max: PetsMaxAggregateOutputType | null
  }

  export type PetsAvgAggregateOutputType = {
    price: number | null
  }

  export type PetsSumAggregateOutputType = {
    price: number | null
  }

  export type PetsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    availability: boolean | null
  }

  export type PetsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    availability: boolean | null
  }

  export type PetsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    availability: number
    _all: number
  }


  export type PetsAvgAggregateInputType = {
    price?: true
  }

  export type PetsSumAggregateInputType = {
    price?: true
  }

  export type PetsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    availability?: true
  }

  export type PetsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    availability?: true
  }

  export type PetsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    availability?: true
    _all?: true
  }

  export type PetsAggregateArgs = {
    /**
     * Filter which Pets to aggregate.
     * 
    **/
    where?: PetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     * 
    **/
    orderBy?: Enumerable<PetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pets
    **/
    _count?: true | PetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetsMaxAggregateInputType
  }

  export type GetPetsAggregateType<T extends PetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePets[P]>
      : GetScalarType<T[P], AggregatePets[P]>
  }




  export type PetsGroupByArgs = {
    where?: PetsWhereInput
    orderBy?: Enumerable<PetsOrderByWithAggregationInput>
    by: Array<PetsScalarFieldEnum>
    having?: PetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetsCountAggregateInputType | true
    _avg?: PetsAvgAggregateInputType
    _sum?: PetsSumAggregateInputType
    _min?: PetsMinAggregateInputType
    _max?: PetsMaxAggregateInputType
  }


  export type PetsGroupByOutputType = {
    id: string
    name: string
    description: string
    price: number
    availability: boolean
    _count: PetsCountAggregateOutputType | null
    _avg: PetsAvgAggregateOutputType | null
    _sum: PetsSumAggregateOutputType | null
    _min: PetsMinAggregateOutputType | null
    _max: PetsMaxAggregateOutputType | null
  }

  type GetPetsGroupByPayload<T extends PetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetsGroupByOutputType[P]>
            : GetScalarType<T[P], PetsGroupByOutputType[P]>
        }
      >
    >


  export type PetsSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    availability?: boolean
  }

  export type PetsGetPayload<
    S extends boolean | null | undefined | PetsArgs,
    U = keyof S
      > = S extends true
        ? Pets
    : S extends undefined
    ? never
    : S extends PetsArgs | PetsFindManyArgs
    ?'include' extends U
    ? Pets 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Pets ? Pets[P] : never
  } 
    : Pets
  : Pets


  type PetsCountArgs = Merge<
    Omit<PetsFindManyArgs, 'select' | 'include'> & {
      select?: PetsCountAggregateInputType | true
    }
  >

  export interface PetsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Pets that matches the filter.
     * @param {PetsFindUniqueArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pets'> extends True ? CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>> : CheckSelect<T, Prisma__PetsClient<Pets | null >, Prisma__PetsClient<PetsGetPayload<T> | null >>

    /**
     * Find the first Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsFindFirstArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pets'> extends True ? CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>> : CheckSelect<T, Prisma__PetsClient<Pets | null >, Prisma__PetsClient<PetsGetPayload<T> | null >>

    /**
     * Find zero or more Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pets
     * const pets = await prisma.pets.findMany()
     * 
     * // Get first 10 Pets
     * const pets = await prisma.pets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petsWithIdOnly = await prisma.pets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PetsFindManyArgs>(
      args?: SelectSubset<T, PetsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pets>>, PrismaPromise<Array<PetsGetPayload<T>>>>

    /**
     * Create a Pets.
     * @param {PetsCreateArgs} args - Arguments to create a Pets.
     * @example
     * // Create one Pets
     * const Pets = await prisma.pets.create({
     *   data: {
     *     // ... data to create a Pets
     *   }
     * })
     * 
    **/
    create<T extends PetsCreateArgs>(
      args: SelectSubset<T, PetsCreateArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Create many Pets.
     *     @param {PetsCreateManyArgs} args - Arguments to create many Pets.
     *     @example
     *     // Create many Pets
     *     const pets = await prisma.pets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PetsCreateManyArgs>(
      args?: SelectSubset<T, PetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pets.
     * @param {PetsDeleteArgs} args - Arguments to delete one Pets.
     * @example
     * // Delete one Pets
     * const Pets = await prisma.pets.delete({
     *   where: {
     *     // ... filter to delete one Pets
     *   }
     * })
     * 
    **/
    delete<T extends PetsDeleteArgs>(
      args: SelectSubset<T, PetsDeleteArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Update one Pets.
     * @param {PetsUpdateArgs} args - Arguments to update one Pets.
     * @example
     * // Update one Pets
     * const pets = await prisma.pets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PetsUpdateArgs>(
      args: SelectSubset<T, PetsUpdateArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Delete zero or more Pets.
     * @param {PetsDeleteManyArgs} args - Arguments to filter Pets to delete.
     * @example
     * // Delete a few Pets
     * const { count } = await prisma.pets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PetsDeleteManyArgs>(
      args?: SelectSubset<T, PetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pets
     * const pets = await prisma.pets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PetsUpdateManyArgs>(
      args: SelectSubset<T, PetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pets.
     * @param {PetsUpsertArgs} args - Arguments to update or create a Pets.
     * @example
     * // Update or create a Pets
     * const pets = await prisma.pets.upsert({
     *   create: {
     *     // ... data to create a Pets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pets we want to update
     *   }
     * })
    **/
    upsert<T extends PetsUpsertArgs>(
      args: SelectSubset<T, PetsUpsertArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Find zero or more Pets that matches the filter.
     * @param {PetsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pets = await prisma.pets.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PetsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Pets.
     * @param {PetsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pets = await prisma.pets.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PetsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Pets that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PetsFindUniqueOrThrowArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PetsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Find the first Pets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsFindFirstOrThrowArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PetsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PetsClient<Pets>, Prisma__PetsClient<PetsGetPayload<T>>>

    /**
     * Count the number of Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsCountArgs} args - Arguments to filter Pets to count.
     * @example
     * // Count the number of Pets
     * const count = await prisma.pets.count({
     *   where: {
     *     // ... the filter for the Pets we want to count
     *   }
     * })
    **/
    count<T extends PetsCountArgs>(
      args?: Subset<T, PetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetsAggregateArgs>(args: Subset<T, PetsAggregateArgs>): PrismaPromise<GetPetsAggregateType<T>>

    /**
     * Group by Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetsGroupByArgs['orderBy'] }
        : { orderBy?: PetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PetsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Pets base type for findUnique actions
   */
  export type PetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * Filter, which Pets to fetch.
     * 
    **/
    where: PetsWhereUniqueInput
  }

  /**
   * Pets: findUnique
   */
  export interface PetsFindUniqueArgs extends PetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pets base type for findFirst actions
   */
  export type PetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * Filter, which Pets to fetch.
     * 
    **/
    where?: PetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     * 
    **/
    orderBy?: Enumerable<PetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     * 
    **/
    cursor?: PetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     * 
    **/
    distinct?: Enumerable<PetsScalarFieldEnum>
  }

  /**
   * Pets: findFirst
   */
  export interface PetsFindFirstArgs extends PetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pets findMany
   */
  export type PetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * Filter, which Pets to fetch.
     * 
    **/
    where?: PetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     * 
    **/
    orderBy?: Enumerable<PetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pets.
     * 
    **/
    cursor?: PetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PetsScalarFieldEnum>
  }


  /**
   * Pets create
   */
  export type PetsCreateArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * The data needed to create a Pets.
     * 
    **/
    data: XOR<PetsCreateInput, PetsUncheckedCreateInput>
  }


  /**
   * Pets createMany
   */
  export type PetsCreateManyArgs = {
    /**
     * The data used to create many Pets.
     * 
    **/
    data: Enumerable<PetsCreateManyInput>
  }


  /**
   * Pets update
   */
  export type PetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * The data needed to update a Pets.
     * 
    **/
    data: XOR<PetsUpdateInput, PetsUncheckedUpdateInput>
    /**
     * Choose, which Pets to update.
     * 
    **/
    where: PetsWhereUniqueInput
  }


  /**
   * Pets updateMany
   */
  export type PetsUpdateManyArgs = {
    /**
     * The data used to update Pets.
     * 
    **/
    data: XOR<PetsUpdateManyMutationInput, PetsUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     * 
    **/
    where?: PetsWhereInput
  }


  /**
   * Pets upsert
   */
  export type PetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * The filter to search for the Pets to update in case it exists.
     * 
    **/
    where: PetsWhereUniqueInput
    /**
     * In case the Pets found by the `where` argument doesn't exist, create a new Pets with this data.
     * 
    **/
    create: XOR<PetsCreateInput, PetsUncheckedCreateInput>
    /**
     * In case the Pets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PetsUpdateInput, PetsUncheckedUpdateInput>
  }


  /**
   * Pets delete
   */
  export type PetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
    /**
     * Filter which Pets to delete.
     * 
    **/
    where: PetsWhereUniqueInput
  }


  /**
   * Pets deleteMany
   */
  export type PetsDeleteManyArgs = {
    /**
     * Filter which Pets to delete
     * 
    **/
    where?: PetsWhereInput
  }


  /**
   * Pets findRaw
   */
  export type PetsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Pets aggregateRaw
   */
  export type PetsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Pets: findUniqueOrThrow
   */
  export type PetsFindUniqueOrThrowArgs = PetsFindUniqueArgsBase
      

  /**
   * Pets: findFirstOrThrow
   */
  export type PetsFindFirstOrThrowArgs = PetsFindFirstArgsBase
      

  /**
   * Pets without action
   */
  export type PetsArgs = {
    /**
     * Select specific fields to fetch from the Pets
     * 
    **/
    select?: PetsSelect | null
  }



  /**
   * Model Wine
   */


  export type AggregateWine = {
    _count: WineCountAggregateOutputType | null
    _avg: WineAvgAggregateOutputType | null
    _sum: WineSumAggregateOutputType | null
    _min: WineMinAggregateOutputType | null
    _max: WineMaxAggregateOutputType | null
  }

  export type WineAvgAggregateOutputType = {
    glassPrice: number | null
    bottlePrice: number | null
    updateTimes: number | null
  }

  export type WineSumAggregateOutputType = {
    glassPrice: number | null
    bottlePrice: number | null
    updateTimes: number | null
  }

  export type WineMinAggregateOutputType = {
    id: string | null
    name: string | null
    glassPrice: number | null
    bottlePrice: number | null
    imageUrl: string | null
    country: string | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type WineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    glassPrice: number | null
    bottlePrice: number | null
    imageUrl: string | null
    country: string | null
    availability: boolean | null
    updateTimes: number | null
  }

  export type WineCountAggregateOutputType = {
    id: number
    name: number
    glassPrice: number
    bottlePrice: number
    imageUrl: number
    country: number
    availability: number
    updateTimes: number
    _all: number
  }


  export type WineAvgAggregateInputType = {
    glassPrice?: true
    bottlePrice?: true
    updateTimes?: true
  }

  export type WineSumAggregateInputType = {
    glassPrice?: true
    bottlePrice?: true
    updateTimes?: true
  }

  export type WineMinAggregateInputType = {
    id?: true
    name?: true
    glassPrice?: true
    bottlePrice?: true
    imageUrl?: true
    country?: true
    availability?: true
    updateTimes?: true
  }

  export type WineMaxAggregateInputType = {
    id?: true
    name?: true
    glassPrice?: true
    bottlePrice?: true
    imageUrl?: true
    country?: true
    availability?: true
    updateTimes?: true
  }

  export type WineCountAggregateInputType = {
    id?: true
    name?: true
    glassPrice?: true
    bottlePrice?: true
    imageUrl?: true
    country?: true
    availability?: true
    updateTimes?: true
    _all?: true
  }

  export type WineAggregateArgs = {
    /**
     * Filter which Wine to aggregate.
     * 
    **/
    where?: WineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wines to fetch.
     * 
    **/
    orderBy?: Enumerable<WineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wines
    **/
    _count?: true | WineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WineMaxAggregateInputType
  }

  export type GetWineAggregateType<T extends WineAggregateArgs> = {
        [P in keyof T & keyof AggregateWine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWine[P]>
      : GetScalarType<T[P], AggregateWine[P]>
  }




  export type WineGroupByArgs = {
    where?: WineWhereInput
    orderBy?: Enumerable<WineOrderByWithAggregationInput>
    by: Array<WineScalarFieldEnum>
    having?: WineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WineCountAggregateInputType | true
    _avg?: WineAvgAggregateInputType
    _sum?: WineSumAggregateInputType
    _min?: WineMinAggregateInputType
    _max?: WineMaxAggregateInputType
  }


  export type WineGroupByOutputType = {
    id: string
    name: string
    glassPrice: number
    bottlePrice: number
    imageUrl: string
    country: string
    availability: boolean
    updateTimes: number
    _count: WineCountAggregateOutputType | null
    _avg: WineAvgAggregateOutputType | null
    _sum: WineSumAggregateOutputType | null
    _min: WineMinAggregateOutputType | null
    _max: WineMaxAggregateOutputType | null
  }

  type GetWineGroupByPayload<T extends WineGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WineGroupByOutputType[P]>
            : GetScalarType<T[P], WineGroupByOutputType[P]>
        }
      >
    >


  export type WineSelect = {
    id?: boolean
    name?: boolean
    glassPrice?: boolean
    bottlePrice?: boolean
    imageUrl?: boolean
    country?: boolean
    availability?: boolean
    updateTimes?: boolean
  }

  export type WineGetPayload<
    S extends boolean | null | undefined | WineArgs,
    U = keyof S
      > = S extends true
        ? Wine
    : S extends undefined
    ? never
    : S extends WineArgs | WineFindManyArgs
    ?'include' extends U
    ? Wine 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Wine ? Wine[P] : never
  } 
    : Wine
  : Wine


  type WineCountArgs = Merge<
    Omit<WineFindManyArgs, 'select' | 'include'> & {
      select?: WineCountAggregateInputType | true
    }
  >

  export interface WineDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Wine that matches the filter.
     * @param {WineFindUniqueArgs} args - Arguments to find a Wine
     * @example
     * // Get one Wine
     * const wine = await prisma.wine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wine'> extends True ? CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>> : CheckSelect<T, Prisma__WineClient<Wine | null >, Prisma__WineClient<WineGetPayload<T> | null >>

    /**
     * Find the first Wine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineFindFirstArgs} args - Arguments to find a Wine
     * @example
     * // Get one Wine
     * const wine = await prisma.wine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wine'> extends True ? CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>> : CheckSelect<T, Prisma__WineClient<Wine | null >, Prisma__WineClient<WineGetPayload<T> | null >>

    /**
     * Find zero or more Wines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wines
     * const wines = await prisma.wine.findMany()
     * 
     * // Get first 10 Wines
     * const wines = await prisma.wine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineWithIdOnly = await prisma.wine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WineFindManyArgs>(
      args?: SelectSubset<T, WineFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Wine>>, PrismaPromise<Array<WineGetPayload<T>>>>

    /**
     * Create a Wine.
     * @param {WineCreateArgs} args - Arguments to create a Wine.
     * @example
     * // Create one Wine
     * const Wine = await prisma.wine.create({
     *   data: {
     *     // ... data to create a Wine
     *   }
     * })
     * 
    **/
    create<T extends WineCreateArgs>(
      args: SelectSubset<T, WineCreateArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Create many Wines.
     *     @param {WineCreateManyArgs} args - Arguments to create many Wines.
     *     @example
     *     // Create many Wines
     *     const wine = await prisma.wine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WineCreateManyArgs>(
      args?: SelectSubset<T, WineCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wine.
     * @param {WineDeleteArgs} args - Arguments to delete one Wine.
     * @example
     * // Delete one Wine
     * const Wine = await prisma.wine.delete({
     *   where: {
     *     // ... filter to delete one Wine
     *   }
     * })
     * 
    **/
    delete<T extends WineDeleteArgs>(
      args: SelectSubset<T, WineDeleteArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Update one Wine.
     * @param {WineUpdateArgs} args - Arguments to update one Wine.
     * @example
     * // Update one Wine
     * const wine = await prisma.wine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineUpdateArgs>(
      args: SelectSubset<T, WineUpdateArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Delete zero or more Wines.
     * @param {WineDeleteManyArgs} args - Arguments to filter Wines to delete.
     * @example
     * // Delete a few Wines
     * const { count } = await prisma.wine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineDeleteManyArgs>(
      args?: SelectSubset<T, WineDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wines
     * const wine = await prisma.wine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineUpdateManyArgs>(
      args: SelectSubset<T, WineUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wine.
     * @param {WineUpsertArgs} args - Arguments to update or create a Wine.
     * @example
     * // Update or create a Wine
     * const wine = await prisma.wine.upsert({
     *   create: {
     *     // ... data to create a Wine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wine we want to update
     *   }
     * })
    **/
    upsert<T extends WineUpsertArgs>(
      args: SelectSubset<T, WineUpsertArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Find zero or more Wines that matches the filter.
     * @param {WineFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wine = await prisma.wine.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WineFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Wine.
     * @param {WineAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wine = await prisma.wine.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WineAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Wine that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WineFindUniqueOrThrowArgs} args - Arguments to find a Wine
     * @example
     * // Get one Wine
     * const wine = await prisma.wine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WineFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Find the first Wine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineFindFirstOrThrowArgs} args - Arguments to find a Wine
     * @example
     * // Get one Wine
     * const wine = await prisma.wine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WineFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WineClient<Wine>, Prisma__WineClient<WineGetPayload<T>>>

    /**
     * Count the number of Wines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineCountArgs} args - Arguments to filter Wines to count.
     * @example
     * // Count the number of Wines
     * const count = await prisma.wine.count({
     *   where: {
     *     // ... the filter for the Wines we want to count
     *   }
     * })
    **/
    count<T extends WineCountArgs>(
      args?: Subset<T, WineCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WineAggregateArgs>(args: Subset<T, WineAggregateArgs>): PrismaPromise<GetWineAggregateType<T>>

    /**
     * Group by Wine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WineGroupByArgs['orderBy'] }
        : { orderBy?: WineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWineGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Wine base type for findUnique actions
   */
  export type WineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * Filter, which Wine to fetch.
     * 
    **/
    where: WineWhereUniqueInput
  }

  /**
   * Wine: findUnique
   */
  export interface WineFindUniqueArgs extends WineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wine base type for findFirst actions
   */
  export type WineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * Filter, which Wine to fetch.
     * 
    **/
    where?: WineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wines to fetch.
     * 
    **/
    orderBy?: Enumerable<WineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wines.
     * 
    **/
    cursor?: WineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wines.
     * 
    **/
    distinct?: Enumerable<WineScalarFieldEnum>
  }

  /**
   * Wine: findFirst
   */
  export interface WineFindFirstArgs extends WineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wine findMany
   */
  export type WineFindManyArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * Filter, which Wines to fetch.
     * 
    **/
    where?: WineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wines to fetch.
     * 
    **/
    orderBy?: Enumerable<WineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wines.
     * 
    **/
    cursor?: WineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wines.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WineScalarFieldEnum>
  }


  /**
   * Wine create
   */
  export type WineCreateArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * The data needed to create a Wine.
     * 
    **/
    data: XOR<WineCreateInput, WineUncheckedCreateInput>
  }


  /**
   * Wine createMany
   */
  export type WineCreateManyArgs = {
    /**
     * The data used to create many Wines.
     * 
    **/
    data: Enumerable<WineCreateManyInput>
  }


  /**
   * Wine update
   */
  export type WineUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * The data needed to update a Wine.
     * 
    **/
    data: XOR<WineUpdateInput, WineUncheckedUpdateInput>
    /**
     * Choose, which Wine to update.
     * 
    **/
    where: WineWhereUniqueInput
  }


  /**
   * Wine updateMany
   */
  export type WineUpdateManyArgs = {
    /**
     * The data used to update Wines.
     * 
    **/
    data: XOR<WineUpdateManyMutationInput, WineUncheckedUpdateManyInput>
    /**
     * Filter which Wines to update
     * 
    **/
    where?: WineWhereInput
  }


  /**
   * Wine upsert
   */
  export type WineUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * The filter to search for the Wine to update in case it exists.
     * 
    **/
    where: WineWhereUniqueInput
    /**
     * In case the Wine found by the `where` argument doesn't exist, create a new Wine with this data.
     * 
    **/
    create: XOR<WineCreateInput, WineUncheckedCreateInput>
    /**
     * In case the Wine was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WineUpdateInput, WineUncheckedUpdateInput>
  }


  /**
   * Wine delete
   */
  export type WineDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
    /**
     * Filter which Wine to delete.
     * 
    **/
    where: WineWhereUniqueInput
  }


  /**
   * Wine deleteMany
   */
  export type WineDeleteManyArgs = {
    /**
     * Filter which Wines to delete
     * 
    **/
    where?: WineWhereInput
  }


  /**
   * Wine findRaw
   */
  export type WineFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Wine aggregateRaw
   */
  export type WineAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Wine: findUniqueOrThrow
   */
  export type WineFindUniqueOrThrowArgs = WineFindUniqueArgsBase
      

  /**
   * Wine: findFirstOrThrow
   */
  export type WineFindFirstOrThrowArgs = WineFindFirstArgsBase
      

  /**
   * Wine without action
   */
  export type WineArgs = {
    /**
     * Select specific fields to fetch from the Wine
     * 
    **/
    select?: WineSelect | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    accountType: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    accountType: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    name: number
    password: number
    accountType: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    accountType?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    accountType?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    accountType?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByWithAggregationInput>
    by: Array<AdminScalarFieldEnum>
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    id: string
    name: string
    password: string
    accountType: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect = {
    id?: boolean
    name?: boolean
    password?: boolean
    accountType?: boolean
  }

  export type AdminGetPayload<
    S extends boolean | null | undefined | AdminArgs,
    U = keyof S
      > = S extends true
        ? Admin
    : S extends undefined
    ? never
    : S extends AdminArgs | AdminFindManyArgs
    ?'include' extends U
    ? Admin 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin ? Admin[P] : never
  } 
    : Admin
  : Admin


  type AdminCountArgs = Merge<
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }
  >

  export interface AdminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admin>>, PrismaPromise<Array<AdminGetPayload<T>>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs>(
      args?: SelectSubset<T, AdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const admin = await prisma.admin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdminFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Admin.
     * @param {AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const admin = await prisma.admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdminAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Admin that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Find the first Admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin base type for findUnique actions
   */
  export type AdminFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     * 
    **/
    where: AdminWhereUniqueInput
  }

  /**
   * Admin: findUnique
   */
  export interface AdminFindUniqueArgs extends AdminFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin base type for findFirst actions
   */
  export type AdminFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     * 
    **/
    distinct?: Enumerable<AdminScalarFieldEnum>
  }

  /**
   * Admin: findFirst
   */
  export interface AdminFindFirstArgs extends AdminFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter, which Admins to fetch.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The data needed to create a Admin.
     * 
    **/
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs = {
    /**
     * The data used to create many Admins.
     * 
    **/
    data: Enumerable<AdminCreateManyInput>
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The data needed to update a Admin.
     * 
    **/
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     * 
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    /**
     * The data used to update Admins.
     * 
    **/
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     * 
    **/
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The filter to search for the Admin to update in case it exists.
     * 
    **/
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     * 
    **/
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter which Admin to delete.
     * 
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    /**
     * Filter which Admins to delete
     * 
    **/
    where?: AdminWhereInput
  }


  /**
   * Admin findRaw
   */
  export type AdminFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Admin aggregateRaw
   */
  export type AdminAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Admin: findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs = AdminFindUniqueArgsBase
      

  /**
   * Admin: findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs = AdminFindFirstArgsBase
      

  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    subtype: 'subtype',
    description: 'description',
    memory: 'memory',
    imageUrl: 'imageUrl',
    price: 'price',
    availability: 'availability',
    priceForTwo: 'priceForTwo',
    updateTimes: 'updateTimes'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AppetizerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageURL: 'imageURL',
    price: 'price',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type AppetizerScalarFieldEnum = (typeof AppetizerScalarFieldEnum)[keyof typeof AppetizerScalarFieldEnum]


  export const SaladScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subtype: 'subtype',
    description: 'description',
    imageURL: 'imageURL',
    price: 'price',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type SaladScalarFieldEnum = (typeof SaladScalarFieldEnum)[keyof typeof SaladScalarFieldEnum]


  export const MainDisheScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subtype: 'subtype',
    description: 'description',
    imageURL: 'imageURL',
    price: 'price',
    priceForTwo: 'priceForTwo',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type MainDisheScalarFieldEnum = (typeof MainDisheScalarFieldEnum)[keyof typeof MainDisheScalarFieldEnum]


  export const DrinkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subtype: 'subtype',
    imageURL: 'imageURL',
    description: 'description',
    price: 'price',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type DrinkScalarFieldEnum = (typeof DrinkScalarFieldEnum)[keyof typeof DrinkScalarFieldEnum]


  export const DessertScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageURL: 'imageURL',
    price: 'price',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type DessertScalarFieldEnum = (typeof DessertScalarFieldEnum)[keyof typeof DessertScalarFieldEnum]


  export const ExtraPortionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    availability: 'availability'
  };

  export type ExtraPortionScalarFieldEnum = (typeof ExtraPortionScalarFieldEnum)[keyof typeof ExtraPortionScalarFieldEnum]


  export const PetsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    availability: 'availability'
  };

  export type PetsScalarFieldEnum = (typeof PetsScalarFieldEnum)[keyof typeof PetsScalarFieldEnum]


  export const WineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    glassPrice: 'glassPrice',
    bottlePrice: 'bottlePrice',
    imageUrl: 'imageUrl',
    country: 'country',
    availability: 'availability',
    updateTimes: 'updateTimes'
  };

  export type WineScalarFieldEnum = (typeof WineScalarFieldEnum)[keyof typeof WineScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    accountType: 'accountType'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    subtype?: StringFilter | string
    description?: StringFilter | string
    memory?: StringFilter | string
    imageUrl?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
    priceForTwo?: FloatFilter | number
    updateTimes?: IntFilter | number
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    memory?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    memory?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    subtype?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    memory?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    priceForTwo?: FloatWithAggregatesFilter | number
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type AppetizerWhereInput = {
    AND?: Enumerable<AppetizerWhereInput>
    OR?: Enumerable<AppetizerWhereInput>
    NOT?: Enumerable<AppetizerWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    imageURL?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type AppetizerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type AppetizerWhereUniqueInput = {
    id?: string
  }

  export type AppetizerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: AppetizerCountOrderByAggregateInput
    _avg?: AppetizerAvgOrderByAggregateInput
    _max?: AppetizerMaxOrderByAggregateInput
    _min?: AppetizerMinOrderByAggregateInput
    _sum?: AppetizerSumOrderByAggregateInput
  }

  export type AppetizerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppetizerScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppetizerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppetizerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    imageURL?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type SaladWhereInput = {
    AND?: Enumerable<SaladWhereInput>
    OR?: Enumerable<SaladWhereInput>
    NOT?: Enumerable<SaladWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    subtype?: StringFilter | string
    description?: StringFilter | string
    imageURL?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type SaladOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladWhereUniqueInput = {
    id?: string
  }

  export type SaladOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: SaladCountOrderByAggregateInput
    _avg?: SaladAvgOrderByAggregateInput
    _max?: SaladMaxOrderByAggregateInput
    _min?: SaladMinOrderByAggregateInput
    _sum?: SaladSumOrderByAggregateInput
  }

  export type SaladScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SaladScalarWhereWithAggregatesInput>
    OR?: Enumerable<SaladScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SaladScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    subtype?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    imageURL?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type MainDisheWhereInput = {
    AND?: Enumerable<MainDisheWhereInput>
    OR?: Enumerable<MainDisheWhereInput>
    NOT?: Enumerable<MainDisheWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    subtype?: StringFilter | string
    description?: StringFilter | string
    imageURL?: StringFilter | string
    price?: FloatFilter | number
    priceForTwo?: FloatFilter | number
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type MainDisheOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    priceForTwo?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheWhereUniqueInput = {
    id?: string
  }

  export type MainDisheOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    priceForTwo?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: MainDisheCountOrderByAggregateInput
    _avg?: MainDisheAvgOrderByAggregateInput
    _max?: MainDisheMaxOrderByAggregateInput
    _min?: MainDisheMinOrderByAggregateInput
    _sum?: MainDisheSumOrderByAggregateInput
  }

  export type MainDisheScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MainDisheScalarWhereWithAggregatesInput>
    OR?: Enumerable<MainDisheScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MainDisheScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    subtype?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    imageURL?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    priceForTwo?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type DrinkWhereInput = {
    AND?: Enumerable<DrinkWhereInput>
    OR?: Enumerable<DrinkWhereInput>
    NOT?: Enumerable<DrinkWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    subtype?: StringFilter | string
    imageURL?: StringFilter | string
    description?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type DrinkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    imageURL?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkWhereUniqueInput = {
    id?: string
  }

  export type DrinkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    imageURL?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: DrinkCountOrderByAggregateInput
    _avg?: DrinkAvgOrderByAggregateInput
    _max?: DrinkMaxOrderByAggregateInput
    _min?: DrinkMinOrderByAggregateInput
    _sum?: DrinkSumOrderByAggregateInput
  }

  export type DrinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DrinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<DrinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DrinkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    subtype?: StringWithAggregatesFilter | string
    imageURL?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type DessertWhereInput = {
    AND?: Enumerable<DessertWhereInput>
    OR?: Enumerable<DessertWhereInput>
    NOT?: Enumerable<DessertWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    imageURL?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type DessertOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertWhereUniqueInput = {
    id?: string
  }

  export type DessertOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: DessertCountOrderByAggregateInput
    _avg?: DessertAvgOrderByAggregateInput
    _max?: DessertMaxOrderByAggregateInput
    _min?: DessertMinOrderByAggregateInput
    _sum?: DessertSumOrderByAggregateInput
  }

  export type DessertScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DessertScalarWhereWithAggregatesInput>
    OR?: Enumerable<DessertScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DessertScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    imageURL?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type ExtraPortionWhereInput = {
    AND?: Enumerable<ExtraPortionWhereInput>
    OR?: Enumerable<ExtraPortionWhereInput>
    NOT?: Enumerable<ExtraPortionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
  }

  export type ExtraPortionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type ExtraPortionWhereUniqueInput = {
    id?: string
  }

  export type ExtraPortionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    _count?: ExtraPortionCountOrderByAggregateInput
    _avg?: ExtraPortionAvgOrderByAggregateInput
    _max?: ExtraPortionMaxOrderByAggregateInput
    _min?: ExtraPortionMinOrderByAggregateInput
    _sum?: ExtraPortionSumOrderByAggregateInput
  }

  export type ExtraPortionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExtraPortionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExtraPortionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExtraPortionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
  }

  export type PetsWhereInput = {
    AND?: Enumerable<PetsWhereInput>
    OR?: Enumerable<PetsWhereInput>
    NOT?: Enumerable<PetsWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    price?: FloatFilter | number
    availability?: BoolFilter | boolean
  }

  export type PetsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type PetsWhereUniqueInput = {
    id?: string
  }

  export type PetsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    _count?: PetsCountOrderByAggregateInput
    _avg?: PetsAvgOrderByAggregateInput
    _max?: PetsMaxOrderByAggregateInput
    _min?: PetsMinOrderByAggregateInput
    _sum?: PetsSumOrderByAggregateInput
  }

  export type PetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PetsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    availability?: BoolWithAggregatesFilter | boolean
  }

  export type WineWhereInput = {
    AND?: Enumerable<WineWhereInput>
    OR?: Enumerable<WineWhereInput>
    NOT?: Enumerable<WineWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    glassPrice?: FloatFilter | number
    bottlePrice?: FloatFilter | number
    imageUrl?: StringFilter | string
    country?: StringFilter | string
    availability?: BoolFilter | boolean
    updateTimes?: IntFilter | number
  }

  export type WineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    imageUrl?: SortOrder
    country?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type WineWhereUniqueInput = {
    id?: string
  }

  export type WineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    imageUrl?: SortOrder
    country?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
    _count?: WineCountOrderByAggregateInput
    _avg?: WineAvgOrderByAggregateInput
    _max?: WineMaxOrderByAggregateInput
    _min?: WineMinOrderByAggregateInput
    _sum?: WineSumOrderByAggregateInput
  }

  export type WineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WineScalarWhereWithAggregatesInput>
    OR?: Enumerable<WineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WineScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    glassPrice?: FloatWithAggregatesFilter | number
    bottlePrice?: FloatWithAggregatesFilter | number
    imageUrl?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    availability?: BoolWithAggregatesFilter | boolean
    updateTimes?: IntWithAggregatesFilter | number
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    password?: StringFilter | string
    accountType?: StringFilter | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    accountType?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    id?: string
  }

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    accountType?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    accountType?: StringWithAggregatesFilter | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    type: string
    subtype: string
    description: string
    memory: string
    imageUrl: string
    price: number
    availability: boolean
    priceForTwo: number
    updateTimes: number
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    subtype: string
    description: string
    memory: string
    imageUrl: string
    price: number
    availability: boolean
    priceForTwo: number
    updateTimes: number
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memory?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memory?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    type: string
    subtype: string
    description: string
    memory: string
    imageUrl: string
    price: number
    availability: boolean
    priceForTwo: number
    updateTimes: number
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memory?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memory?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type AppetizerCreateInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type AppetizerUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type AppetizerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type AppetizerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type AppetizerCreateManyInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type AppetizerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type AppetizerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type SaladCreateInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type SaladUncheckedCreateInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type SaladUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type SaladUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type SaladCreateManyInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type SaladUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type SaladUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type MainDisheCreateInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    priceForTwo: number
    availability: boolean
    updateTimes: number
  }

  export type MainDisheUncheckedCreateInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    priceForTwo: number
    availability: boolean
    updateTimes: number
  }

  export type MainDisheUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type MainDisheUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type MainDisheCreateManyInput = {
    id?: string
    name: string
    subtype: string
    description: string
    imageURL: string
    price: number
    priceForTwo: number
    availability: boolean
    updateTimes: number
  }

  export type MainDisheUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type MainDisheUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceForTwo?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DrinkCreateInput = {
    id?: string
    name: string
    subtype: string
    imageURL: string
    description: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DrinkUncheckedCreateInput = {
    id?: string
    name: string
    subtype: string
    imageURL: string
    description: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DrinkUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DrinkUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DrinkCreateManyInput = {
    id?: string
    name: string
    subtype: string
    imageURL: string
    description: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DrinkUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DrinkUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DessertCreateInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DessertUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DessertUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DessertUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DessertCreateManyInput = {
    id?: string
    name: string
    description: string
    imageURL: string
    price: number
    availability: boolean
    updateTimes: number
  }

  export type DessertUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type DessertUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageURL?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type ExtraPortionCreateInput = {
    id?: string
    name: string
    price: number
    availability: boolean
  }

  export type ExtraPortionUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    availability: boolean
  }

  export type ExtraPortionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraPortionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraPortionCreateManyInput = {
    id?: string
    name: string
    price: number
    availability: boolean
  }

  export type ExtraPortionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraPortionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PetsCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    availability: boolean
  }

  export type PetsUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    availability: boolean
  }

  export type PetsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PetsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PetsCreateManyInput = {
    id?: string
    name: string
    description: string
    price: number
    availability: boolean
  }

  export type PetsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PetsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WineCreateInput = {
    id?: string
    name: string
    glassPrice: number
    bottlePrice: number
    imageUrl: string
    country: string
    availability: boolean
    updateTimes: number
  }

  export type WineUncheckedCreateInput = {
    id?: string
    name: string
    glassPrice: number
    bottlePrice: number
    imageUrl: string
    country: string
    availability: boolean
    updateTimes: number
  }

  export type WineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    glassPrice?: FloatFieldUpdateOperationsInput | number
    bottlePrice?: FloatFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type WineUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    glassPrice?: FloatFieldUpdateOperationsInput | number
    bottlePrice?: FloatFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type WineCreateManyInput = {
    id?: string
    name: string
    glassPrice: number
    bottlePrice: number
    imageUrl: string
    country: string
    availability: boolean
    updateTimes: number
  }

  export type WineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    glassPrice?: FloatFieldUpdateOperationsInput | number
    bottlePrice?: FloatFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type WineUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    glassPrice?: FloatFieldUpdateOperationsInput | number
    bottlePrice?: FloatFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    availability?: BoolFieldUpdateOperationsInput | boolean
    updateTimes?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateInput = {
    id?: string
    name: string
    password: string
    accountType: string
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    name: string
    password: string
    accountType: string
  }

  export type AdminUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: string
    name: string
    password: string
    accountType: string
  }

  export type AdminUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    memory?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    memory?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    memory?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type AppetizerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type AppetizerAvgOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type AppetizerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type AppetizerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type AppetizerSumOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladAvgOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type SaladSumOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    priceForTwo?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheAvgOrderByAggregateInput = {
    price?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    priceForTwo?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    priceForTwo?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type MainDisheSumOrderByAggregateInput = {
    price?: SortOrder
    priceForTwo?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    imageURL?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkAvgOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    imageURL?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subtype?: SortOrder
    imageURL?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DrinkSumOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertAvgOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageURL?: SortOrder
    price?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type DessertSumOrderByAggregateInput = {
    price?: SortOrder
    updateTimes?: SortOrder
  }

  export type ExtraPortionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type ExtraPortionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ExtraPortionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type ExtraPortionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type ExtraPortionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PetsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type PetsAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PetsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type PetsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    availability?: SortOrder
  }

  export type PetsSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type WineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    imageUrl?: SortOrder
    country?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type WineAvgOrderByAggregateInput = {
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    updateTimes?: SortOrder
  }

  export type WineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    imageUrl?: SortOrder
    country?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type WineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    imageUrl?: SortOrder
    country?: SortOrder
    availability?: SortOrder
    updateTimes?: SortOrder
  }

  export type WineSumOrderByAggregateInput = {
    glassPrice?: SortOrder
    bottlePrice?: SortOrder
    updateTimes?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    accountType?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    accountType?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    accountType?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}